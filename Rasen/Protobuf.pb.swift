// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: Protobuf.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2024 Cii
//
// This file is part of Rasen.
//
// Rasen is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Rasen is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Rasen.  If not, see <http://www.gnu.org/licenses/>.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum PBRGBColorSpace: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case sRgb // = 0
  case sRgblinear // = 4
  case sRgbhdr // = 1
  case sRgbhdrlinear // = 5
  case p3 // = 2
  case p3Linear // = 6
  case p3Hdr // = 3
  case p3Hdrlinear // = 7
  case UNRECOGNIZED(Int)

  init() {
    self = .sRgb
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .sRgb
    case 1: self = .sRgbhdr
    case 2: self = .p3
    case 3: self = .p3Hdr
    case 4: self = .sRgblinear
    case 5: self = .sRgbhdrlinear
    case 6: self = .p3Linear
    case 7: self = .p3Hdrlinear
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .sRgb: return 0
    case .sRgbhdr: return 1
    case .p3: return 2
    case .p3Hdr: return 3
    case .sRgblinear: return 4
    case .sRgbhdrlinear: return 5
    case .p3Linear: return 6
    case .p3Hdrlinear: return 7
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [PBRGBColorSpace] = [
    .sRgb,
    .sRgblinear,
    .sRgbhdr,
    .sRgbhdrlinear,
    .p3,
    .p3Linear,
    .p3Hdr,
    .p3Hdrlinear,
  ]

}

enum PBInterType: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case none // = 0
  case key // = 1
  case interpolated // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .none
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .none
    case 1: self = .key
    case 2: self = .interpolated
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .none: return 0
    case .key: return 1
    case .interpolated: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [PBInterType] = [
    .none,
    .key,
    .interpolated,
  ]

}

enum PBOrientation: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case horizontal // = 0
  case vertical // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .horizontal
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .horizontal
    case 1: self = .vertical
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .horizontal: return 0
    case .vertical: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [PBOrientation] = [
    .horizontal,
    .vertical,
  ]

}

enum PBPreviousNext: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case off // = 0
  case previous // = 1
  case next // = 2
  case previousAndNext // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .off
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .off
    case 1: self = .previous
    case 2: self = .next
    case 3: self = .previousAndNext
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .off: return 0
    case .previous: return 1
    case .next: return 2
    case .previousAndNext: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [PBPreviousNext] = [
    .off,
    .previous,
    .next,
    .previousAndNext,
  ]

}

enum PBRectCorner: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case minXminY // = 0
  case minXmaxY // = 1
  case maxXminY // = 2
  case maxXmaxY // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .minXminY
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .minXminY
    case 1: self = .minXmaxY
    case 2: self = .maxXminY
    case 3: self = .maxXmaxY
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .minXminY: return 0
    case .minXmaxY: return 1
    case .maxXminY: return 2
    case .maxXmaxY: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [PBRectCorner] = [
    .minXminY,
    .minXmaxY,
    .maxXminY,
    .maxXmaxY,
  ]

}

struct PBRational: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var p: Int64 = 0

  var q: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBIntRange: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var lowerBound: Int64 = 0

  var upperBound: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBRationalRange: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var lowerBound: PBRational {
    get {return _lowerBound ?? PBRational()}
    set {_lowerBound = newValue}
  }
  /// Returns true if `lowerBound` has been explicitly set.
  var hasLowerBound: Bool {return self._lowerBound != nil}
  /// Clears the value of `lowerBound`. Subsequent reads from it will return its default value.
  mutating func clearLowerBound() {self._lowerBound = nil}

  var upperBound: PBRational {
    get {return _upperBound ?? PBRational()}
    set {_upperBound = newValue}
  }
  /// Returns true if `upperBound` has been explicitly set.
  var hasUpperBound: Bool {return self._upperBound != nil}
  /// Clears the value of `upperBound`. Subsequent reads from it will return its default value.
  mutating func clearUpperBound() {self._upperBound = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _lowerBound: PBRational? = nil
  fileprivate var _upperBound: PBRational? = nil
}

struct PBPoint: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var x: Double = 0

  var y: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBSize: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var width: Double = 0

  var height: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBRect: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var origin: PBPoint {
    get {return _origin ?? PBPoint()}
    set {_origin = newValue}
  }
  /// Returns true if `origin` has been explicitly set.
  var hasOrigin: Bool {return self._origin != nil}
  /// Clears the value of `origin`. Subsequent reads from it will return its default value.
  mutating func clearOrigin() {self._origin = nil}

  var size: PBSize {
    get {return _size ?? PBSize()}
    set {_size = newValue}
  }
  /// Returns true if `size` has been explicitly set.
  var hasSize: Bool {return self._size != nil}
  /// Clears the value of `size`. Subsequent reads from it will return its default value.
  mutating func clearSize() {self._size = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _origin: PBPoint? = nil
  fileprivate var _size: PBSize? = nil
}

struct PBAttitude: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var position: PBPoint {
    get {return _position ?? PBPoint()}
    set {_position = newValue}
  }
  /// Returns true if `position` has been explicitly set.
  var hasPosition: Bool {return self._position != nil}
  /// Clears the value of `position`. Subsequent reads from it will return its default value.
  mutating func clearPosition() {self._position = nil}

  var scale: PBSize {
    get {return _scale ?? PBSize()}
    set {_scale = newValue}
  }
  /// Returns true if `scale` has been explicitly set.
  var hasScale: Bool {return self._scale != nil}
  /// Clears the value of `scale`. Subsequent reads from it will return its default value.
  mutating func clearScale() {self._scale = nil}

  var rotation: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _position: PBPoint? = nil
  fileprivate var _scale: PBSize? = nil
}

struct PBLCHA: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var l: Double = 0

  var c: Double = 0

  var h: Double = 0

  var a: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBRGBA: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var r: Float = 0

  var g: Float = 0

  var b: Float = 0

  var a: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBColor: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var lcha: PBLCHA {
    get {return _lcha ?? PBLCHA()}
    set {_lcha = newValue}
  }
  /// Returns true if `lcha` has been explicitly set.
  var hasLcha: Bool {return self._lcha != nil}
  /// Clears the value of `lcha`. Subsequent reads from it will return its default value.
  mutating func clearLcha() {self._lcha = nil}

  var rgba: PBRGBA {
    get {return _rgba ?? PBRGBA()}
    set {_rgba = newValue}
  }
  /// Returns true if `rgba` has been explicitly set.
  var hasRgba: Bool {return self._rgba != nil}
  /// Clears the value of `rgba`. Subsequent reads from it will return its default value.
  mutating func clearRgba() {self._rgba = nil}

  var rgbColorSpace: PBRGBColorSpace = .sRgb

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _lcha: PBLCHA? = nil
  fileprivate var _rgba: PBRGBA? = nil
}

struct PBUUID: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: String = String()

  var data: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBUUColor: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: PBColor {
    get {return _value ?? PBColor()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  var id: PBUUID {
    get {return _id ?? PBUUID()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _value: PBColor? = nil
  fileprivate var _id: PBUUID? = nil
}

struct PBInterOption: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: PBUUID {
    get {return _id ?? PBUUID()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  var interType: PBInterType = .none

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _id: PBUUID? = nil
}

struct PBLine: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var controls: [PBLine.PBControl] {
    get {return _storage._controls}
    set {_uniqueStorage()._controls = newValue}
  }

  var size: Double {
    get {return _storage._size}
    set {_uniqueStorage()._size = newValue}
  }

  var id: PBUUID {
    get {return _storage._id ?? PBUUID()}
    set {_uniqueStorage()._id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return _storage._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {_uniqueStorage()._id = nil}

  var interType: PBInterType {
    get {return _storage._interType}
    set {_uniqueStorage()._interType = newValue}
  }

  var controlsData: Data {
    get {return _storage._controlsData}
    set {_uniqueStorage()._controlsData = newValue}
  }

  var uuColorOptional: OneOf_UuColorOptional? {
    get {return _storage._uuColorOptional}
    set {_uniqueStorage()._uuColorOptional = newValue}
  }

  var uuColor: PBUUColor {
    get {
      if case .uuColor(let v)? = _storage._uuColorOptional {return v}
      return PBUUColor()
    }
    set {_uniqueStorage()._uuColorOptional = .uuColor(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_UuColorOptional: Equatable, Sendable {
    case uuColor(PBUUColor)

  }

  struct PBControl: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var point: PBPoint {
      get {return _point ?? PBPoint()}
      set {_point = newValue}
    }
    /// Returns true if `point` has been explicitly set.
    var hasPoint: Bool {return self._point != nil}
    /// Clears the value of `point`. Subsequent reads from it will return its default value.
    mutating func clearPoint() {self._point = nil}

    var weight: Double = 0

    var pressure: Double = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _point: PBPoint? = nil
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct PBPolygon: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var points: [PBPoint] = []

  var pointsData: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBTopolygon: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var polygon: PBPolygon {
    get {return _polygon ?? PBPolygon()}
    set {_polygon = newValue}
  }
  /// Returns true if `polygon` has been explicitly set.
  var hasPolygon: Bool {return self._polygon != nil}
  /// Clears the value of `polygon`. Subsequent reads from it will return its default value.
  mutating func clearPolygon() {self._polygon = nil}

  var holePolygons: [PBPolygon] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _polygon: PBPolygon? = nil
}

struct PBPlane: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var topolygon: PBTopolygon {
    get {return _topolygon ?? PBTopolygon()}
    set {_topolygon = newValue}
  }
  /// Returns true if `topolygon` has been explicitly set.
  var hasTopolygon: Bool {return self._topolygon != nil}
  /// Clears the value of `topolygon`. Subsequent reads from it will return its default value.
  mutating func clearTopolygon() {self._topolygon = nil}

  var polygon: PBPolygon {
    get {return _polygon ?? PBPolygon()}
    set {_polygon = newValue}
  }
  /// Returns true if `polygon` has been explicitly set.
  var hasPolygon: Bool {return self._polygon != nil}
  /// Clears the value of `polygon`. Subsequent reads from it will return its default value.
  mutating func clearPolygon() {self._polygon = nil}

  var uuColor: PBUUColor {
    get {return _uuColor ?? PBUUColor()}
    set {_uuColor = newValue}
  }
  /// Returns true if `uuColor` has been explicitly set.
  var hasUuColor: Bool {return self._uuColor != nil}
  /// Clears the value of `uuColor`. Subsequent reads from it will return its default value.
  mutating func clearUuColor() {self._uuColor = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _topolygon: PBTopolygon? = nil
  fileprivate var _polygon: PBPolygon? = nil
  fileprivate var _uuColor: PBUUColor? = nil
}

struct PBPicture: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var lines: [PBLine] = []

  var planes: [PBPlane] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBDate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var timestamp: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBContentTimeOption: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var beatRange: PBRationalRange {
    get {return _beatRange ?? PBRationalRange()}
    set {_beatRange = newValue}
  }
  /// Returns true if `beatRange` has been explicitly set.
  var hasBeatRange: Bool {return self._beatRange != nil}
  /// Clears the value of `beatRange`. Subsequent reads from it will return its default value.
  mutating func clearBeatRange() {self._beatRange = nil}

  var localStartBeat: PBRational {
    get {return _localStartBeat ?? PBRational()}
    set {_localStartBeat = newValue}
  }
  /// Returns true if `localStartBeat` has been explicitly set.
  var hasLocalStartBeat: Bool {return self._localStartBeat != nil}
  /// Clears the value of `localStartBeat`. Subsequent reads from it will return its default value.
  mutating func clearLocalStartBeat() {self._localStartBeat = nil}

  var tempo: PBRational {
    get {return _tempo ?? PBRational()}
    set {_tempo = newValue}
  }
  /// Returns true if `tempo` has been explicitly set.
  var hasTempo: Bool {return self._tempo != nil}
  /// Clears the value of `tempo`. Subsequent reads from it will return its default value.
  mutating func clearTempo() {self._tempo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _beatRange: PBRationalRange? = nil
  fileprivate var _localStartBeat: PBRational? = nil
  fileprivate var _tempo: PBRational? = nil
}

struct PBImage: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var data: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBStereo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var volm: Double = 0

  var pan: Double = 0

  var id: PBUUID {
    get {return _id ?? PBUUID()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _id: PBUUID? = nil
}

struct PBContent: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var directoryName: String {
    get {return _storage._directoryName}
    set {_uniqueStorage()._directoryName = newValue}
  }

  var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  var stereo: PBStereo {
    get {return _storage._stereo ?? PBStereo()}
    set {_uniqueStorage()._stereo = newValue}
  }
  /// Returns true if `stereo` has been explicitly set.
  var hasStereo: Bool {return _storage._stereo != nil}
  /// Clears the value of `stereo`. Subsequent reads from it will return its default value.
  mutating func clearStereo() {_uniqueStorage()._stereo = nil}

  var size: PBSize {
    get {return _storage._size ?? PBSize()}
    set {_uniqueStorage()._size = newValue}
  }
  /// Returns true if `size` has been explicitly set.
  var hasSize: Bool {return _storage._size != nil}
  /// Clears the value of `size`. Subsequent reads from it will return its default value.
  mutating func clearSize() {_uniqueStorage()._size = nil}

  var origin: PBPoint {
    get {return _storage._origin ?? PBPoint()}
    set {_uniqueStorage()._origin = newValue}
  }
  /// Returns true if `origin` has been explicitly set.
  var hasOrigin: Bool {return _storage._origin != nil}
  /// Clears the value of `origin`. Subsequent reads from it will return its default value.
  mutating func clearOrigin() {_uniqueStorage()._origin = nil}

  var isShownSpectrogram: Bool {
    get {return _storage._isShownSpectrogram}
    set {_uniqueStorage()._isShownSpectrogram = newValue}
  }

  var contentTimeOptionOptional: OneOf_ContentTimeOptionOptional? {
    get {return _storage._contentTimeOptionOptional}
    set {_uniqueStorage()._contentTimeOptionOptional = newValue}
  }

  var timeOption: PBContentTimeOption {
    get {
      if case .timeOption(let v)? = _storage._contentTimeOptionOptional {return v}
      return PBContentTimeOption()
    }
    set {_uniqueStorage()._contentTimeOptionOptional = .timeOption(newValue)}
  }

  var beat: PBRational {
    get {return _storage._beat ?? PBRational()}
    set {_uniqueStorage()._beat = newValue}
  }
  /// Returns true if `beat` has been explicitly set.
  var hasBeat: Bool {return _storage._beat != nil}
  /// Clears the value of `beat`. Subsequent reads from it will return its default value.
  mutating func clearBeat() {_uniqueStorage()._beat = nil}

  var durSec: PBRational {
    get {return _storage._durSec ?? PBRational()}
    set {_uniqueStorage()._durSec = newValue}
  }
  /// Returns true if `durSec` has been explicitly set.
  var hasDurSec: Bool {return _storage._durSec != nil}
  /// Clears the value of `durSec`. Subsequent reads from it will return its default value.
  mutating func clearDurSec() {_uniqueStorage()._durSec = nil}

  var frameRate: PBRational {
    get {return _storage._frameRate ?? PBRational()}
    set {_uniqueStorage()._frameRate = newValue}
  }
  /// Returns true if `frameRate` has been explicitly set.
  var hasFrameRate: Bool {return _storage._frameRate != nil}
  /// Clears the value of `frameRate`. Subsequent reads from it will return its default value.
  mutating func clearFrameRate() {_uniqueStorage()._frameRate = nil}

  var id: PBUUID {
    get {return _storage._id ?? PBUUID()}
    set {_uniqueStorage()._id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return _storage._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {_uniqueStorage()._id = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_ContentTimeOptionOptional: Equatable, Sendable {
    case timeOption(PBContentTimeOption)

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct PBOvertone: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var evenVolm: Double = 0

  var oddVolm: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBSprol: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pitch: Double = 0

  var volm: Double = 0

  var noise: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBSpectlope: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sprols: [PBSprol] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBTone: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var overtone: PBOvertone {
    get {return _overtone ?? PBOvertone()}
    set {_overtone = newValue}
  }
  /// Returns true if `overtone` has been explicitly set.
  var hasOvertone: Bool {return self._overtone != nil}
  /// Clears the value of `overtone`. Subsequent reads from it will return its default value.
  mutating func clearOvertone() {self._overtone = nil}

  var spectlope: PBSpectlope {
    get {return _spectlope ?? PBSpectlope()}
    set {_spectlope = newValue}
  }
  /// Returns true if `spectlope` has been explicitly set.
  var hasSpectlope: Bool {return self._spectlope != nil}
  /// Clears the value of `spectlope`. Subsequent reads from it will return its default value.
  mutating func clearSpectlope() {self._spectlope = nil}

  var color: PBColor {
    get {return _color ?? PBColor()}
    set {_color = newValue}
  }
  /// Returns true if `color` has been explicitly set.
  var hasColor: Bool {return self._color != nil}
  /// Clears the value of `color`. Subsequent reads from it will return its default value.
  mutating func clearColor() {self._color = nil}

  var id: PBUUID {
    get {return _id ?? PBUUID()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _overtone: PBOvertone? = nil
  fileprivate var _spectlope: PBSpectlope? = nil
  fileprivate var _color: PBColor? = nil
  fileprivate var _id: PBUUID? = nil
}

struct PBPit: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var beat: PBRational {
    get {return _storage._beat ?? PBRational()}
    set {_uniqueStorage()._beat = newValue}
  }
  /// Returns true if `beat` has been explicitly set.
  var hasBeat: Bool {return _storage._beat != nil}
  /// Clears the value of `beat`. Subsequent reads from it will return its default value.
  mutating func clearBeat() {_uniqueStorage()._beat = nil}

  var pitch: PBRational {
    get {return _storage._pitch ?? PBRational()}
    set {_uniqueStorage()._pitch = newValue}
  }
  /// Returns true if `pitch` has been explicitly set.
  var hasPitch: Bool {return _storage._pitch != nil}
  /// Clears the value of `pitch`. Subsequent reads from it will return its default value.
  mutating func clearPitch() {_uniqueStorage()._pitch = nil}

  var stereo: PBStereo {
    get {return _storage._stereo ?? PBStereo()}
    set {_uniqueStorage()._stereo = newValue}
  }
  /// Returns true if `stereo` has been explicitly set.
  var hasStereo: Bool {return _storage._stereo != nil}
  /// Clears the value of `stereo`. Subsequent reads from it will return its default value.
  mutating func clearStereo() {_uniqueStorage()._stereo = nil}

  var tone: PBTone {
    get {return _storage._tone ?? PBTone()}
    set {_uniqueStorage()._tone = newValue}
  }
  /// Returns true if `tone` has been explicitly set.
  var hasTone: Bool {return _storage._tone != nil}
  /// Clears the value of `tone`. Subsequent reads from it will return its default value.
  mutating func clearTone() {_uniqueStorage()._tone = nil}

  var lyric: String {
    get {return _storage._lyric}
    set {_uniqueStorage()._lyric = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct PBPitbend: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pits: [PBPit] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBReverb: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var earlyRsec: Double = 0

  var earlyRvolm: Double = 0

  var lateRsec: Double = 0

  var lateRvolm: Double = 0

  var releaseSec: Double = 0

  var seedID: PBUUID {
    get {return _seedID ?? PBUUID()}
    set {_seedID = newValue}
  }
  /// Returns true if `seedID` has been explicitly set.
  var hasSeedID: Bool {return self._seedID != nil}
  /// Clears the value of `seedID`. Subsequent reads from it will return its default value.
  mutating func clearSeedID() {self._seedID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _seedID: PBUUID? = nil
}

struct PBEnvelope: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var attackSec: Double = 0

  var decaySec: Double = 0

  var sustainVolm: Double = 0

  var releaseSec: Double = 0

  var reverb: PBReverb {
    get {return _reverb ?? PBReverb()}
    set {_reverb = newValue}
  }
  /// Returns true if `reverb` has been explicitly set.
  var hasReverb: Bool {return self._reverb != nil}
  /// Clears the value of `reverb`. Subsequent reads from it will return its default value.
  mutating func clearReverb() {self._reverb = nil}

  var id: PBUUID {
    get {return _id ?? PBUUID()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _reverb: PBReverb? = nil
  fileprivate var _id: PBUUID? = nil
}

struct PBNote: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pitch: PBRational {
    get {return _storage._pitch ?? PBRational()}
    set {_uniqueStorage()._pitch = newValue}
  }
  /// Returns true if `pitch` has been explicitly set.
  var hasPitch: Bool {return _storage._pitch != nil}
  /// Clears the value of `pitch`. Subsequent reads from it will return its default value.
  mutating func clearPitch() {_uniqueStorage()._pitch = nil}

  var pits: [PBPit] {
    get {return _storage._pits}
    set {_uniqueStorage()._pits = newValue}
  }

  var beatRange: PBRationalRange {
    get {return _storage._beatRange ?? PBRationalRange()}
    set {_uniqueStorage()._beatRange = newValue}
  }
  /// Returns true if `beatRange` has been explicitly set.
  var hasBeatRange: Bool {return _storage._beatRange != nil}
  /// Clears the value of `beatRange`. Subsequent reads from it will return its default value.
  mutating func clearBeatRange() {_uniqueStorage()._beatRange = nil}

  var envelope: PBEnvelope {
    get {return _storage._envelope ?? PBEnvelope()}
    set {_uniqueStorage()._envelope = newValue}
  }
  /// Returns true if `envelope` has been explicitly set.
  var hasEnvelope: Bool {return _storage._envelope != nil}
  /// Clears the value of `envelope`. Subsequent reads from it will return its default value.
  mutating func clearEnvelope() {_uniqueStorage()._envelope = nil}

  var id: PBUUID {
    get {return _storage._id ?? PBUUID()}
    set {_uniqueStorage()._id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return _storage._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {_uniqueStorage()._id = nil}

  var isShownTone: Bool {
    get {return _storage._isShownTone}
    set {_uniqueStorage()._isShownTone = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct PBScoreOption: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var durBeat: PBRational {
    get {return _durBeat ?? PBRational()}
    set {_durBeat = newValue}
  }
  /// Returns true if `durBeat` has been explicitly set.
  var hasDurBeat: Bool {return self._durBeat != nil}
  /// Clears the value of `durBeat`. Subsequent reads from it will return its default value.
  mutating func clearDurBeat() {self._durBeat = nil}

  var tempo: PBRational {
    get {return _tempo ?? PBRational()}
    set {_tempo = newValue}
  }
  /// Returns true if `tempo` has been explicitly set.
  var hasTempo: Bool {return self._tempo != nil}
  /// Clears the value of `tempo`. Subsequent reads from it will return its default value.
  mutating func clearTempo() {self._tempo = nil}

  var keyBeats: [PBRational] = []

  var enabled: Bool = false

  var isShownSpectrogram: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _durBeat: PBRational? = nil
  fileprivate var _tempo: PBRational? = nil
}

struct PBScore: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var notes: [PBNote] = []

  var draftNotes: [PBNote] = []

  var durBeat: PBRational {
    get {return _durBeat ?? PBRational()}
    set {_durBeat = newValue}
  }
  /// Returns true if `durBeat` has been explicitly set.
  var hasDurBeat: Bool {return self._durBeat != nil}
  /// Clears the value of `durBeat`. Subsequent reads from it will return its default value.
  mutating func clearDurBeat() {self._durBeat = nil}

  var tempo: PBRational {
    get {return _tempo ?? PBRational()}
    set {_tempo = newValue}
  }
  /// Returns true if `tempo` has been explicitly set.
  var hasTempo: Bool {return self._tempo != nil}
  /// Clears the value of `tempo`. Subsequent reads from it will return its default value.
  mutating func clearTempo() {self._tempo = nil}

  var keyBeats: [PBRational] = []

  var enabled: Bool = false

  var isShownSpectrogram: Bool = false

  var id: PBUUID {
    get {return _id ?? PBUUID()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _durBeat: PBRational? = nil
  fileprivate var _tempo: PBRational? = nil
  fileprivate var _id: PBUUID? = nil
}

struct PBAudio: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pcmData: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBLocale: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var identifier: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBTextTimeOption: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var beatRange: PBRationalRange {
    get {return _beatRange ?? PBRationalRange()}
    set {_beatRange = newValue}
  }
  /// Returns true if `beatRange` has been explicitly set.
  var hasBeatRange: Bool {return self._beatRange != nil}
  /// Clears the value of `beatRange`. Subsequent reads from it will return its default value.
  mutating func clearBeatRange() {self._beatRange = nil}

  var tempo: PBRational {
    get {return _tempo ?? PBRational()}
    set {_tempo = newValue}
  }
  /// Returns true if `tempo` has been explicitly set.
  var hasTempo: Bool {return self._tempo != nil}
  /// Clears the value of `tempo`. Subsequent reads from it will return its default value.
  mutating func clearTempo() {self._tempo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _beatRange: PBRationalRange? = nil
  fileprivate var _tempo: PBRational? = nil
}

struct PBText: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var string: String = String()

  var orientation: PBOrientation = .horizontal

  var size: Double = 0

  var widthCount: Double = 0

  var origin: PBPoint {
    get {return _origin ?? PBPoint()}
    set {_origin = newValue}
  }
  /// Returns true if `origin` has been explicitly set.
  var hasOrigin: Bool {return self._origin != nil}
  /// Clears the value of `origin`. Subsequent reads from it will return its default value.
  mutating func clearOrigin() {self._origin = nil}

  var locale: PBLocale {
    get {return _locale ?? PBLocale()}
    set {_locale = newValue}
  }
  /// Returns true if `locale` has been explicitly set.
  var hasLocale: Bool {return self._locale != nil}
  /// Clears the value of `locale`. Subsequent reads from it will return its default value.
  mutating func clearLocale() {self._locale = nil}

  var timeOptionOptional: PBText.OneOf_TimeOptionOptional? = nil

  var timeOption: PBTextTimeOption {
    get {
      if case .timeOption(let v)? = timeOptionOptional {return v}
      return PBTextTimeOption()
    }
    set {timeOptionOptional = .timeOption(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_TimeOptionOptional: Equatable, Sendable {
    case timeOption(PBTextTimeOption)

  }

  init() {}

  fileprivate var _origin: PBPoint? = nil
  fileprivate var _locale: PBLocale? = nil
}

struct PBBorder: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var location: Double = 0

  var orientation: PBOrientation = .horizontal

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBSheetposStringDic: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: Dictionary<String,PBSheetpos> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBStringIntPointDicElement: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: PBSheetpos {
    get {return _key ?? PBSheetpos()}
    set {_key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  var hasKey: Bool {return self._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  mutating func clearKey() {self._key = nil}

  var value: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _key: PBSheetpos? = nil
}

struct PBStringIntPointDic: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: [PBStringIntPointDicElement] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBKeyframe: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var picture: PBPicture {
    get {return _picture ?? PBPicture()}
    set {_picture = newValue}
  }
  /// Returns true if `picture` has been explicitly set.
  var hasPicture: Bool {return self._picture != nil}
  /// Clears the value of `picture`. Subsequent reads from it will return its default value.
  mutating func clearPicture() {self._picture = nil}

  var draftPicture: PBPicture {
    get {return _draftPicture ?? PBPicture()}
    set {_draftPicture = newValue}
  }
  /// Returns true if `draftPicture` has been explicitly set.
  var hasDraftPicture: Bool {return self._draftPicture != nil}
  /// Clears the value of `draftPicture`. Subsequent reads from it will return its default value.
  mutating func clearDraftPicture() {self._draftPicture = nil}

  var beat: PBRational {
    get {return _beat ?? PBRational()}
    set {_beat = newValue}
  }
  /// Returns true if `beat` has been explicitly set.
  var hasBeat: Bool {return self._beat != nil}
  /// Clears the value of `beat`. Subsequent reads from it will return its default value.
  mutating func clearBeat() {self._beat = nil}

  var previousNext: PBPreviousNext = .off

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _picture: PBPicture? = nil
  fileprivate var _draftPicture: PBPicture? = nil
  fileprivate var _beat: PBRational? = nil
}

struct PBKeyframeKey: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var lineIs: [Int64] = []

  var planeIs: [Int64] = []

  var draftLineIs: [Int64] = []

  var draftPlaneIs: [Int64] = []

  var beat: PBRational {
    get {return _beat ?? PBRational()}
    set {_beat = newValue}
  }
  /// Returns true if `beat` has been explicitly set.
  var hasBeat: Bool {return self._beat != nil}
  /// Clears the value of `beat`. Subsequent reads from it will return its default value.
  mutating func clearBeat() {self._beat = nil}

  var previousNext: PBPreviousNext = .off

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _beat: PBRational? = nil
}

struct PBAnimationZipper: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var keys: [PBKeyframeKey] = []

  var lines: [PBLine] = []

  var planes: [PBPlane] = []

  var draftLines: [PBLine] = []

  var draftPlanes: [PBPlane] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBAnimationOption: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var beatRange: PBRationalRange {
    get {return _beatRange ?? PBRationalRange()}
    set {_beatRange = newValue}
  }
  /// Returns true if `beatRange` has been explicitly set.
  var hasBeatRange: Bool {return self._beatRange != nil}
  /// Clears the value of `beatRange`. Subsequent reads from it will return its default value.
  mutating func clearBeatRange() {self._beatRange = nil}

  var tempo: PBRational {
    get {return _tempo ?? PBRational()}
    set {_tempo = newValue}
  }
  /// Returns true if `tempo` has been explicitly set.
  var hasTempo: Bool {return self._tempo != nil}
  /// Clears the value of `tempo`. Subsequent reads from it will return its default value.
  mutating func clearTempo() {self._tempo = nil}

  var timelineY: Double = 0

  var enabled: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _beatRange: PBRationalRange? = nil
  fileprivate var _tempo: PBRational? = nil
}

struct PBAnimation: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var keyframes: [PBKeyframe] {
    get {return _storage._keyframes}
    set {_uniqueStorage()._keyframes = newValue}
  }

  var zipper: PBAnimationZipper {
    get {return _storage._zipper ?? PBAnimationZipper()}
    set {_uniqueStorage()._zipper = newValue}
  }
  /// Returns true if `zipper` has been explicitly set.
  var hasZipper: Bool {return _storage._zipper != nil}
  /// Clears the value of `zipper`. Subsequent reads from it will return its default value.
  mutating func clearZipper() {_uniqueStorage()._zipper = nil}

  var rootBeat: PBRational {
    get {return _storage._rootBeat ?? PBRational()}
    set {_uniqueStorage()._rootBeat = newValue}
  }
  /// Returns true if `rootBeat` has been explicitly set.
  var hasRootBeat: Bool {return _storage._rootBeat != nil}
  /// Clears the value of `rootBeat`. Subsequent reads from it will return its default value.
  mutating func clearRootBeat() {_uniqueStorage()._rootBeat = nil}

  var beatRange: PBRationalRange {
    get {return _storage._beatRange ?? PBRationalRange()}
    set {_uniqueStorage()._beatRange = newValue}
  }
  /// Returns true if `beatRange` has been explicitly set.
  var hasBeatRange: Bool {return _storage._beatRange != nil}
  /// Clears the value of `beatRange`. Subsequent reads from it will return its default value.
  mutating func clearBeatRange() {_uniqueStorage()._beatRange = nil}

  var tempo: PBRational {
    get {return _storage._tempo ?? PBRational()}
    set {_uniqueStorage()._tempo = newValue}
  }
  /// Returns true if `tempo` has been explicitly set.
  var hasTempo: Bool {return _storage._tempo != nil}
  /// Clears the value of `tempo`. Subsequent reads from it will return its default value.
  mutating func clearTempo() {_uniqueStorage()._tempo = nil}

  var isPlaying: Bool {
    get {return _storage._isPlaying}
    set {_uniqueStorage()._isPlaying = newValue}
  }

  var timelineY: Double {
    get {return _storage._timelineY}
    set {_uniqueStorage()._timelineY = newValue}
  }

  var enabled: Bool {
    get {return _storage._enabled}
    set {_uniqueStorage()._enabled = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct PBSheetOption: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var durBeat: PBRational {
    get {return _durBeat ?? PBRational()}
    set {_durBeat = newValue}
  }
  /// Returns true if `durBeat` has been explicitly set.
  var hasDurBeat: Bool {return self._durBeat != nil}
  /// Clears the value of `durBeat`. Subsequent reads from it will return its default value.
  mutating func clearDurBeat() {self._durBeat = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _durBeat: PBRational? = nil
}

struct PBSheet: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var animation: PBAnimation {
    get {return _storage._animation ?? PBAnimation()}
    set {_uniqueStorage()._animation = newValue}
  }
  /// Returns true if `animation` has been explicitly set.
  var hasAnimation: Bool {return _storage._animation != nil}
  /// Clears the value of `animation`. Subsequent reads from it will return its default value.
  mutating func clearAnimation() {_uniqueStorage()._animation = nil}

  var score: PBScore {
    get {return _storage._score ?? PBScore()}
    set {_uniqueStorage()._score = newValue}
  }
  /// Returns true if `score` has been explicitly set.
  var hasScore: Bool {return _storage._score != nil}
  /// Clears the value of `score`. Subsequent reads from it will return its default value.
  mutating func clearScore() {_uniqueStorage()._score = nil}

  var picture: PBPicture {
    get {return _storage._picture ?? PBPicture()}
    set {_uniqueStorage()._picture = newValue}
  }
  /// Returns true if `picture` has been explicitly set.
  var hasPicture: Bool {return _storage._picture != nil}
  /// Clears the value of `picture`. Subsequent reads from it will return its default value.
  mutating func clearPicture() {_uniqueStorage()._picture = nil}

  var draftPicture: PBPicture {
    get {return _storage._draftPicture ?? PBPicture()}
    set {_uniqueStorage()._draftPicture = newValue}
  }
  /// Returns true if `draftPicture` has been explicitly set.
  var hasDraftPicture: Bool {return _storage._draftPicture != nil}
  /// Clears the value of `draftPicture`. Subsequent reads from it will return its default value.
  mutating func clearDraftPicture() {_uniqueStorage()._draftPicture = nil}

  var texts: [PBText] {
    get {return _storage._texts}
    set {_uniqueStorage()._texts = newValue}
  }

  var contents: [PBContent] {
    get {return _storage._contents}
    set {_uniqueStorage()._contents = newValue}
  }

  var borders: [PBBorder] {
    get {return _storage._borders}
    set {_uniqueStorage()._borders = newValue}
  }

  var rects: [PBRect] {
    get {return _storage._rects}
    set {_uniqueStorage()._rects = newValue}
  }

  var backgroundUucolor: PBUUColor {
    get {return _storage._backgroundUucolor ?? PBUUColor()}
    set {_uniqueStorage()._backgroundUucolor = newValue}
  }
  /// Returns true if `backgroundUucolor` has been explicitly set.
  var hasBackgroundUucolor: Bool {return _storage._backgroundUucolor != nil}
  /// Clears the value of `backgroundUucolor`. Subsequent reads from it will return its default value.
  mutating func clearBackgroundUucolor() {_uniqueStorage()._backgroundUucolor = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct PBSheetpos: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var x: Int64 = 0

  var y: Int64 = 0

  var isRight: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBWorld: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sheetPositions: PBSheetposStringDic {
    get {return _sheetPositions ?? PBSheetposStringDic()}
    set {_sheetPositions = newValue}
  }
  /// Returns true if `sheetPositions` has been explicitly set.
  var hasSheetPositions: Bool {return self._sheetPositions != nil}
  /// Clears the value of `sheetPositions`. Subsequent reads from it will return its default value.
  mutating func clearSheetPositions() {self._sheetPositions = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _sheetPositions: PBSheetposStringDic? = nil
}

struct PBCornerRectValue: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var rect: PBRect {
    get {return _rect ?? PBRect()}
    set {_rect = newValue}
  }
  /// Returns true if `rect` has been explicitly set.
  var hasRect: Bool {return self._rect != nil}
  /// Clears the value of `rect`. Subsequent reads from it will return its default value.
  mutating func clearRect() {self._rect = nil}

  var rectCorner: PBRectCorner = .minXminY

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _rect: PBRect? = nil
}

struct PBCornerRectValueArray: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: [PBCornerRectValue] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBFinding: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var worldPosition: PBPoint {
    get {return _worldPosition ?? PBPoint()}
    set {_worldPosition = newValue}
  }
  /// Returns true if `worldPosition` has been explicitly set.
  var hasWorldPosition: Bool {return self._worldPosition != nil}
  /// Clears the value of `worldPosition`. Subsequent reads from it will return its default value.
  mutating func clearWorldPosition() {self._worldPosition = nil}

  var string: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _worldPosition: PBPoint? = nil
}

struct PBKeyframeOption: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var beat: PBRational {
    get {return _beat ?? PBRational()}
    set {_beat = newValue}
  }
  /// Returns true if `beat` has been explicitly set.
  var hasBeat: Bool {return self._beat != nil}
  /// Clears the value of `beat`. Subsequent reads from it will return its default value.
  mutating func clearBeat() {self._beat = nil}

  var previousNext: PBPreviousNext = .off

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _beat: PBRational? = nil
}

struct PBBoolIndexValue: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: Bool = false

  var index: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBIntIndexValue: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: Int64 = 0

  var index: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBLineIndexValue: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: PBLine {
    get {return _value ?? PBLine()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  var index: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _value: PBLine? = nil
}

struct PBInterOptionIndexValue: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: PBInterOption {
    get {return _value ?? PBInterOption()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  var index: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _value: PBInterOption? = nil
}

struct PBPlaneIndexValue: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: PBPlane {
    get {return _storage._value ?? PBPlane()}
    set {_uniqueStorage()._value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return _storage._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {_uniqueStorage()._value = nil}

  var index: Int64 {
    get {return _storage._index}
    set {_uniqueStorage()._index = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct PBTextIndexValue: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: PBText {
    get {return _value ?? PBText()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  var index: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _value: PBText? = nil
}

struct PBNoteIndexValue: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: PBNote {
    get {return _value ?? PBNote()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  var index: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _value: PBNote? = nil
}

struct PBContentIndexValue: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: PBContent {
    get {return _value ?? PBContent()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  var index: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _value: PBContent? = nil
}

struct PBBorderIndexValue: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: PBBorder {
    get {return _value ?? PBBorder()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  var index: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _value: PBBorder? = nil
}

struct PBKeyframeIndexValue: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: PBKeyframe {
    get {return _value ?? PBKeyframe()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  var index: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _value: PBKeyframe? = nil
}

struct PBKeyframeOptionIndexValue: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: PBKeyframeOption {
    get {return _value ?? PBKeyframeOption()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  var index: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _value: PBKeyframeOption? = nil
}

struct PBColorValue: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uuColor: PBUUColor {
    get {return _storage._uuColor ?? PBUUColor()}
    set {_uniqueStorage()._uuColor = newValue}
  }
  /// Returns true if `uuColor` has been explicitly set.
  var hasUuColor: Bool {return _storage._uuColor != nil}
  /// Clears the value of `uuColor`. Subsequent reads from it will return its default value.
  mutating func clearUuColor() {_uniqueStorage()._uuColor = nil}

  var planeIndexes: [Int64] {
    get {return _storage._planeIndexes}
    set {_uniqueStorage()._planeIndexes = newValue}
  }

  var lineIndexes: [Int64] {
    get {return _storage._lineIndexes}
    set {_uniqueStorage()._lineIndexes = newValue}
  }

  var planeAnimationIndexes: PBIntArrayIndexValueArray {
    get {return _storage._planeAnimationIndexes ?? PBIntArrayIndexValueArray()}
    set {_uniqueStorage()._planeAnimationIndexes = newValue}
  }
  /// Returns true if `planeAnimationIndexes` has been explicitly set.
  var hasPlaneAnimationIndexes: Bool {return _storage._planeAnimationIndexes != nil}
  /// Clears the value of `planeAnimationIndexes`. Subsequent reads from it will return its default value.
  mutating func clearPlaneAnimationIndexes() {_uniqueStorage()._planeAnimationIndexes = nil}

  var lineAnimationIndexes: PBIntArrayIndexValueArray {
    get {return _storage._lineAnimationIndexes ?? PBIntArrayIndexValueArray()}
    set {_uniqueStorage()._lineAnimationIndexes = newValue}
  }
  /// Returns true if `lineAnimationIndexes` has been explicitly set.
  var hasLineAnimationIndexes: Bool {return _storage._lineAnimationIndexes != nil}
  /// Clears the value of `lineAnimationIndexes`. Subsequent reads from it will return its default value.
  mutating func clearLineAnimationIndexes() {_uniqueStorage()._lineAnimationIndexes = nil}

  var animationColors: [PBColor] {
    get {return _storage._animationColors}
    set {_uniqueStorage()._animationColors = newValue}
  }

  var isBackground: Bool {
    get {return _storage._isBackground}
    set {_uniqueStorage()._isBackground = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct PBPlaneValue: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var planes: [PBPlane] = []

  var moveIndexValues: [PBIntIndexValue] = []

  var index: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBTextValue: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var string: String = String()

  var replacedRange: PBIntRange {
    get {return _replacedRange ?? PBIntRange()}
    set {_replacedRange = newValue}
  }
  /// Returns true if `replacedRange` has been explicitly set.
  var hasReplacedRange: Bool {return self._replacedRange != nil}
  /// Clears the value of `replacedRange`. Subsequent reads from it will return its default value.
  mutating func clearReplacedRange() {self._replacedRange = nil}

  var originOptional: PBTextValue.OneOf_OriginOptional? = nil

  var origin: PBPoint {
    get {
      if case .origin(let v)? = originOptional {return v}
      return PBPoint()
    }
    set {originOptional = .origin(newValue)}
  }

  var sizeOptional: PBTextValue.OneOf_SizeOptional? = nil

  var size: Double {
    get {
      if case .size(let v)? = sizeOptional {return v}
      return 0
    }
    set {sizeOptional = .size(newValue)}
  }

  var widthCountOptional: PBTextValue.OneOf_WidthCountOptional? = nil

  var widthCount: Double {
    get {
      if case .widthCount(let v)? = widthCountOptional {return v}
      return 0
    }
    set {widthCountOptional = .widthCount(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_OriginOptional: Equatable, Sendable {
    case origin(PBPoint)

  }

  enum OneOf_SizeOptional: Equatable, Sendable {
    case size(Double)

  }

  enum OneOf_WidthCountOptional: Equatable, Sendable {
    case widthCount(Double)

  }

  init() {}

  fileprivate var _replacedRange: PBIntRange? = nil
}

struct PBTextValueIndexValue: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: PBTextValue {
    get {return _value ?? PBTextValue()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  var index: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _value: PBTextValue? = nil
}

struct PBSheetValue: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var lines: [PBLine] = []

  var planes: [PBPlane] = []

  var texts: [PBText] = []

  var origin: PBPoint {
    get {return _origin ?? PBPoint()}
    set {_origin = newValue}
  }
  /// Returns true if `origin` has been explicitly set.
  var hasOrigin: Bool {return self._origin != nil}
  /// Clears the value of `origin`. Subsequent reads from it will return its default value.
  mutating func clearOrigin() {self._origin = nil}

  var id: PBUUID {
    get {return _id ?? PBUUID()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  var rootKeyframeIndex: Int64 = 0

  var keyframes: [PBKeyframe] = []

  var keyframeBeganIndex: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _origin: PBPoint? = nil
  fileprivate var _id: PBUUID? = nil
}

struct PBInt64Array: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: [Int64] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBIntArrayIndexValue: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: PBInt64Array {
    get {return _value ?? PBInt64Array()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  var index: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _value: PBInt64Array? = nil
}

struct PBIntArrayIndexValueArray: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: [PBIntArrayIndexValue] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBLineArray: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: [PBLine] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBPlaneArray: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: [PBPlane] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBSheetposArray: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: [PBSheetpos] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBIntIndexValueArray: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: [PBIntIndexValue] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBLineIndexValueArray: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: [PBLineIndexValue] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBLineIndexValueArrayIndexValue: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: [PBLineIndexValue] = []

  var index: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBLineIndexValueArrayIndexValueArray: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: [PBLineIndexValueArrayIndexValue] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBPlaneIndexValueArrayIndexValue: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: [PBPlaneIndexValue] = []

  var index: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBPlaneIndexValueArrayIndexValueArray: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: [PBPlaneIndexValueArrayIndexValue] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBInterOptionIndexValueArray: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: [PBInterOptionIndexValue] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBInterOptionIndexValueArrayIndexValue: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: [PBInterOptionIndexValue] = []

  var index: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBInterOptionIndexValueArrayIndexValueArray: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: [PBInterOptionIndexValueArrayIndexValue] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBBoolIndexValueArray: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: [PBBoolIndexValue] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBPlaneIndexValueArray: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: [PBPlaneIndexValue] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBNoteIndexValueArray: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: [PBNoteIndexValue] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBTextIndexValueArray: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: [PBTextIndexValue] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBContentIndexValueArray: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: [PBContentIndexValue] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBBorderIndexValueArray: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: [PBBorderIndexValue] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBKeyframeIndexValueArray: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: [PBKeyframeIndexValue] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBKeyframeOptionIndexValueArray: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: [PBKeyframeOptionIndexValue] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBSheetUndoItem: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: PBSheetUndoItem.OneOf_Value? = nil

  var appendLine: PBLine {
    get {
      if case .appendLine(let v)? = value {return v}
      return PBLine()
    }
    set {value = .appendLine(newValue)}
  }

  var appendLines: PBLineArray {
    get {
      if case .appendLines(let v)? = value {return v}
      return PBLineArray()
    }
    set {value = .appendLines(newValue)}
  }

  var appendPlanes: PBPlaneArray {
    get {
      if case .appendPlanes(let v)? = value {return v}
      return PBPlaneArray()
    }
    set {value = .appendPlanes(newValue)}
  }

  var removeLastLines: Int64 {
    get {
      if case .removeLastLines(let v)? = value {return v}
      return 0
    }
    set {value = .removeLastLines(newValue)}
  }

  var removeLastPlanes: Int64 {
    get {
      if case .removeLastPlanes(let v)? = value {return v}
      return 0
    }
    set {value = .removeLastPlanes(newValue)}
  }

  var insertLines: PBLineIndexValueArray {
    get {
      if case .insertLines(let v)? = value {return v}
      return PBLineIndexValueArray()
    }
    set {value = .insertLines(newValue)}
  }

  var insertPlanes: PBPlaneIndexValueArray {
    get {
      if case .insertPlanes(let v)? = value {return v}
      return PBPlaneIndexValueArray()
    }
    set {value = .insertPlanes(newValue)}
  }

  var removeLines: PBInt64Array {
    get {
      if case .removeLines(let v)? = value {return v}
      return PBInt64Array()
    }
    set {value = .removeLines(newValue)}
  }

  var removePlanes: PBInt64Array {
    get {
      if case .removePlanes(let v)? = value {return v}
      return PBInt64Array()
    }
    set {value = .removePlanes(newValue)}
  }

  var setPlaneValue: PBPlaneValue {
    get {
      if case .setPlaneValue(let v)? = value {return v}
      return PBPlaneValue()
    }
    set {value = .setPlaneValue(newValue)}
  }

  var changeToDraft: Bool {
    get {
      if case .changeToDraft(let v)? = value {return v}
      return false
    }
    set {value = .changeToDraft(newValue)}
  }

  var setPicture: PBPicture {
    get {
      if case .setPicture(let v)? = value {return v}
      return PBPicture()
    }
    set {value = .setPicture(newValue)}
  }

  var insertDraftLines: PBLineIndexValueArray {
    get {
      if case .insertDraftLines(let v)? = value {return v}
      return PBLineIndexValueArray()
    }
    set {value = .insertDraftLines(newValue)}
  }

  var insertDraftPlanes: PBPlaneIndexValueArray {
    get {
      if case .insertDraftPlanes(let v)? = value {return v}
      return PBPlaneIndexValueArray()
    }
    set {value = .insertDraftPlanes(newValue)}
  }

  var removeDraftLines: PBInt64Array {
    get {
      if case .removeDraftLines(let v)? = value {return v}
      return PBInt64Array()
    }
    set {value = .removeDraftLines(newValue)}
  }

  var removeDraftPlanes: PBInt64Array {
    get {
      if case .removeDraftPlanes(let v)? = value {return v}
      return PBInt64Array()
    }
    set {value = .removeDraftPlanes(newValue)}
  }

  var setDraftPicture: PBPicture {
    get {
      if case .setDraftPicture(let v)? = value {return v}
      return PBPicture()
    }
    set {value = .setDraftPicture(newValue)}
  }

  var insertTexts: PBTextIndexValueArray {
    get {
      if case .insertTexts(let v)? = value {return v}
      return PBTextIndexValueArray()
    }
    set {value = .insertTexts(newValue)}
  }

  var removeTexts: PBInt64Array {
    get {
      if case .removeTexts(let v)? = value {return v}
      return PBInt64Array()
    }
    set {value = .removeTexts(newValue)}
  }

  var replaceString: PBTextValueIndexValue {
    get {
      if case .replaceString(let v)? = value {return v}
      return PBTextValueIndexValue()
    }
    set {value = .replaceString(newValue)}
  }

  var changedColors: PBColorValue {
    get {
      if case .changedColors(let v)? = value {return v}
      return PBColorValue()
    }
    set {value = .changedColors(newValue)}
  }

  var insertBorders: PBBorderIndexValueArray {
    get {
      if case .insertBorders(let v)? = value {return v}
      return PBBorderIndexValueArray()
    }
    set {value = .insertBorders(newValue)}
  }

  var removeBorders: PBInt64Array {
    get {
      if case .removeBorders(let v)? = value {return v}
      return PBInt64Array()
    }
    set {value = .removeBorders(newValue)}
  }

  var setRootKeyframeIndex: Int64 {
    get {
      if case .setRootKeyframeIndex(let v)? = value {return v}
      return 0
    }
    set {value = .setRootKeyframeIndex(newValue)}
  }

  var insertKeyframes: PBKeyframeIndexValueArray {
    get {
      if case .insertKeyframes(let v)? = value {return v}
      return PBKeyframeIndexValueArray()
    }
    set {value = .insertKeyframes(newValue)}
  }

  var removeKeyframes: PBInt64Array {
    get {
      if case .removeKeyframes(let v)? = value {return v}
      return PBInt64Array()
    }
    set {value = .removeKeyframes(newValue)}
  }

  var setKeyframeOptions: PBKeyframeOptionIndexValueArray {
    get {
      if case .setKeyframeOptions(let v)? = value {return v}
      return PBKeyframeOptionIndexValueArray()
    }
    set {value = .setKeyframeOptions(newValue)}
  }

  var insertKeyLines: PBLineIndexValueArrayIndexValueArray {
    get {
      if case .insertKeyLines(let v)? = value {return v}
      return PBLineIndexValueArrayIndexValueArray()
    }
    set {value = .insertKeyLines(newValue)}
  }

  var replaceKeyLines: PBLineIndexValueArrayIndexValueArray {
    get {
      if case .replaceKeyLines(let v)? = value {return v}
      return PBLineIndexValueArrayIndexValueArray()
    }
    set {value = .replaceKeyLines(newValue)}
  }

  var removeKeyLines: PBIntArrayIndexValueArray {
    get {
      if case .removeKeyLines(let v)? = value {return v}
      return PBIntArrayIndexValueArray()
    }
    set {value = .removeKeyLines(newValue)}
  }

  var insertKeyPlanes: PBPlaneIndexValueArrayIndexValueArray {
    get {
      if case .insertKeyPlanes(let v)? = value {return v}
      return PBPlaneIndexValueArrayIndexValueArray()
    }
    set {value = .insertKeyPlanes(newValue)}
  }

  var replaceKeyPlanes: PBPlaneIndexValueArrayIndexValueArray {
    get {
      if case .replaceKeyPlanes(let v)? = value {return v}
      return PBPlaneIndexValueArrayIndexValueArray()
    }
    set {value = .replaceKeyPlanes(newValue)}
  }

  var removeKeyPlanes: PBIntArrayIndexValueArray {
    get {
      if case .removeKeyPlanes(let v)? = value {return v}
      return PBIntArrayIndexValueArray()
    }
    set {value = .removeKeyPlanes(newValue)}
  }

  var insertDraftKeyLines: PBLineIndexValueArrayIndexValueArray {
    get {
      if case .insertDraftKeyLines(let v)? = value {return v}
      return PBLineIndexValueArrayIndexValueArray()
    }
    set {value = .insertDraftKeyLines(newValue)}
  }

  var removeDraftKeyLines: PBIntArrayIndexValueArray {
    get {
      if case .removeDraftKeyLines(let v)? = value {return v}
      return PBIntArrayIndexValueArray()
    }
    set {value = .removeDraftKeyLines(newValue)}
  }

  var insertDraftKeyPlanes: PBPlaneIndexValueArrayIndexValueArray {
    get {
      if case .insertDraftKeyPlanes(let v)? = value {return v}
      return PBPlaneIndexValueArrayIndexValueArray()
    }
    set {value = .insertDraftKeyPlanes(newValue)}
  }

  var removeDraftKeyPlanes: PBIntArrayIndexValueArray {
    get {
      if case .removeDraftKeyPlanes(let v)? = value {return v}
      return PBIntArrayIndexValueArray()
    }
    set {value = .removeDraftKeyPlanes(newValue)}
  }

  var setLineIds: PBInterOptionIndexValueArrayIndexValueArray {
    get {
      if case .setLineIds(let v)? = value {return v}
      return PBInterOptionIndexValueArrayIndexValueArray()
    }
    set {value = .setLineIds(newValue)}
  }

  var setAnimationOption: PBAnimationOption {
    get {
      if case .setAnimationOption(let v)? = value {return v}
      return PBAnimationOption()
    }
    set {value = .setAnimationOption(newValue)}
  }

  var insertNotes: PBNoteIndexValueArray {
    get {
      if case .insertNotes(let v)? = value {return v}
      return PBNoteIndexValueArray()
    }
    set {value = .insertNotes(newValue)}
  }

  var replaceNotes: PBNoteIndexValueArray {
    get {
      if case .replaceNotes(let v)? = value {return v}
      return PBNoteIndexValueArray()
    }
    set {value = .replaceNotes(newValue)}
  }

  var removeNotes: PBInt64Array {
    get {
      if case .removeNotes(let v)? = value {return v}
      return PBInt64Array()
    }
    set {value = .removeNotes(newValue)}
  }

  var insertContents: PBContentIndexValueArray {
    get {
      if case .insertContents(let v)? = value {return v}
      return PBContentIndexValueArray()
    }
    set {value = .insertContents(newValue)}
  }

  var replaceContents: PBContentIndexValueArray {
    get {
      if case .replaceContents(let v)? = value {return v}
      return PBContentIndexValueArray()
    }
    set {value = .replaceContents(newValue)}
  }

  var removeContents: PBInt64Array {
    get {
      if case .removeContents(let v)? = value {return v}
      return PBInt64Array()
    }
    set {value = .removeContents(newValue)}
  }

  var setScoreOption: PBScoreOption {
    get {
      if case .setScoreOption(let v)? = value {return v}
      return PBScoreOption()
    }
    set {value = .setScoreOption(newValue)}
  }

  var insertDraftNotes: PBNoteIndexValueArray {
    get {
      if case .insertDraftNotes(let v)? = value {return v}
      return PBNoteIndexValueArray()
    }
    set {value = .insertDraftNotes(newValue)}
  }

  var removeDraftNotes: PBInt64Array {
    get {
      if case .removeDraftNotes(let v)? = value {return v}
      return PBInt64Array()
    }
    set {value = .removeDraftNotes(newValue)}
  }

  var setIsShownTones: PBBoolIndexValueArray {
    get {
      if case .setIsShownTones(let v)? = value {return v}
      return PBBoolIndexValueArray()
    }
    set {value = .setIsShownTones(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Value: Equatable, Sendable {
    case appendLine(PBLine)
    case appendLines(PBLineArray)
    case appendPlanes(PBPlaneArray)
    case removeLastLines(Int64)
    case removeLastPlanes(Int64)
    case insertLines(PBLineIndexValueArray)
    case insertPlanes(PBPlaneIndexValueArray)
    case removeLines(PBInt64Array)
    case removePlanes(PBInt64Array)
    case setPlaneValue(PBPlaneValue)
    case changeToDraft(Bool)
    case setPicture(PBPicture)
    case insertDraftLines(PBLineIndexValueArray)
    case insertDraftPlanes(PBPlaneIndexValueArray)
    case removeDraftLines(PBInt64Array)
    case removeDraftPlanes(PBInt64Array)
    case setDraftPicture(PBPicture)
    case insertTexts(PBTextIndexValueArray)
    case removeTexts(PBInt64Array)
    case replaceString(PBTextValueIndexValue)
    case changedColors(PBColorValue)
    case insertBorders(PBBorderIndexValueArray)
    case removeBorders(PBInt64Array)
    case setRootKeyframeIndex(Int64)
    case insertKeyframes(PBKeyframeIndexValueArray)
    case removeKeyframes(PBInt64Array)
    case setKeyframeOptions(PBKeyframeOptionIndexValueArray)
    case insertKeyLines(PBLineIndexValueArrayIndexValueArray)
    case replaceKeyLines(PBLineIndexValueArrayIndexValueArray)
    case removeKeyLines(PBIntArrayIndexValueArray)
    case insertKeyPlanes(PBPlaneIndexValueArrayIndexValueArray)
    case replaceKeyPlanes(PBPlaneIndexValueArrayIndexValueArray)
    case removeKeyPlanes(PBIntArrayIndexValueArray)
    case insertDraftKeyLines(PBLineIndexValueArrayIndexValueArray)
    case removeDraftKeyLines(PBIntArrayIndexValueArray)
    case insertDraftKeyPlanes(PBPlaneIndexValueArrayIndexValueArray)
    case removeDraftKeyPlanes(PBIntArrayIndexValueArray)
    case setLineIds(PBInterOptionIndexValueArrayIndexValueArray)
    case setAnimationOption(PBAnimationOption)
    case insertNotes(PBNoteIndexValueArray)
    case replaceNotes(PBNoteIndexValueArray)
    case removeNotes(PBInt64Array)
    case insertContents(PBContentIndexValueArray)
    case replaceContents(PBContentIndexValueArray)
    case removeContents(PBInt64Array)
    case setScoreOption(PBScoreOption)
    case insertDraftNotes(PBNoteIndexValueArray)
    case removeDraftNotes(PBInt64Array)
    case setIsShownTones(PBBoolIndexValueArray)

  }

  init() {}
}

struct PBWorldUndoItem: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: PBWorldUndoItem.OneOf_Value? = nil

  var insertSheets: PBStringIntPointDic {
    get {
      if case .insertSheets(let v)? = value {return v}
      return PBStringIntPointDic()
    }
    set {value = .insertSheets(newValue)}
  }

  var removeSheets: PBSheetposArray {
    get {
      if case .removeSheets(let v)? = value {return v}
      return PBSheetposArray()
    }
    set {value = .removeSheets(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Value: Equatable, Sendable {
    case insertSheets(PBStringIntPointDic)
    case removeSheets(PBSheetposArray)

  }

  init() {}
}

struct PBUndoDataValue: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var undoItemData: Data = Data()

  var redoItemData: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBUndoGroup: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var values: [PBUndoDataValue] = []

  var isFirstReverse: Bool = false

  var date: PBDate {
    get {return _date ?? PBDate()}
    set {_date = newValue}
  }
  /// Returns true if `date` has been explicitly set.
  var hasDate: Bool {return self._date != nil}
  /// Clears the value of `date`. Subsequent reads from it will return its default value.
  mutating func clearDate() {self._date = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _date: PBDate? = nil
}

struct PBBranch: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var groups: [PBUndoGroup] = []

  var childrenCount: Int64 = 0

  var selectedChildIndexOptional: PBBranch.OneOf_SelectedChildIndexOptional? = nil

  var selectedChildIndex: Int64 {
    get {
      if case .selectedChildIndex(let v)? = selectedChildIndexOptional {return v}
      return 0
    }
    set {selectedChildIndexOptional = .selectedChildIndex(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_SelectedChildIndexOptional: Equatable, Sendable {
    case selectedChildIndex(Int64)

  }

  init() {}
}

struct PBBranchCoder: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var allBranches: [PBBranch] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBHistory: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var branchCoder: PBBranchCoder {
    get {return _branchCoder ?? PBBranchCoder()}
    set {_branchCoder = newValue}
  }
  /// Returns true if `branchCoder` has been explicitly set.
  var hasBranchCoder: Bool {return self._branchCoder != nil}
  /// Clears the value of `branchCoder`. Subsequent reads from it will return its default value.
  mutating func clearBranchCoder() {self._branchCoder = nil}

  var currentVersionIndex: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _branchCoder: PBBranchCoder? = nil
}

struct PBCopiedSheetsValue: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var deltaPoint: PBPoint {
    get {return _deltaPoint ?? PBPoint()}
    set {_deltaPoint = newValue}
  }
  /// Returns true if `deltaPoint` has been explicitly set.
  var hasDeltaPoint: Bool {return self._deltaPoint != nil}
  /// Clears the value of `deltaPoint`. Subsequent reads from it will return its default value.
  mutating func clearDeltaPoint() {self._deltaPoint = nil}

  var sheetIds: PBStringIntPointDic {
    get {return _sheetIds ?? PBStringIntPointDic()}
    set {_sheetIds = newValue}
  }
  /// Returns true if `sheetIds` has been explicitly set.
  var hasSheetIds: Bool {return self._sheetIds != nil}
  /// Clears the value of `sheetIds`. Subsequent reads from it will return its default value.
  mutating func clearSheetIds() {self._sheetIds = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _deltaPoint: PBPoint? = nil
  fileprivate var _sheetIds: PBStringIntPointDic? = nil
}

struct PBPlanesValue: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var planes: [PBPlane] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBNotesValue: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var notes: [PBNote] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PBInterOptionsValue: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ids: [PBInterOption] = []

  var sheetID: PBUUID {
    get {return _sheetID ?? PBUUID()}
    set {_sheetID = newValue}
  }
  /// Returns true if `sheetID` has been explicitly set.
  var hasSheetID: Bool {return self._sheetID != nil}
  /// Clears the value of `sheetID`. Subsequent reads from it will return its default value.
  mutating func clearSheetID() {self._sheetID = nil}

  var rootKeyframeIndex: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _sheetID: PBUUID? = nil
}

struct PBPastableObject: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: PBPastableObject.OneOf_Value? = nil

  var copiedSheetsValue: PBCopiedSheetsValue {
    get {
      if case .copiedSheetsValue(let v)? = value {return v}
      return PBCopiedSheetsValue()
    }
    set {value = .copiedSheetsValue(newValue)}
  }

  var sheetValue: PBSheetValue {
    get {
      if case .sheetValue(let v)? = value {return v}
      return PBSheetValue()
    }
    set {value = .sheetValue(newValue)}
  }

  var border: PBBorder {
    get {
      if case .border(let v)? = value {return v}
      return PBBorder()
    }
    set {value = .border(newValue)}
  }

  var text: PBText {
    get {
      if case .text(let v)? = value {return v}
      return PBText()
    }
    set {value = .text(newValue)}
  }

  var string: String {
    get {
      if case .string(let v)? = value {return v}
      return String()
    }
    set {value = .string(newValue)}
  }

  var picture: PBPicture {
    get {
      if case .picture(let v)? = value {return v}
      return PBPicture()
    }
    set {value = .picture(newValue)}
  }

  var planesValue: PBPlanesValue {
    get {
      if case .planesValue(let v)? = value {return v}
      return PBPlanesValue()
    }
    set {value = .planesValue(newValue)}
  }

  var uuColor: PBUUColor {
    get {
      if case .uuColor(let v)? = value {return v}
      return PBUUColor()
    }
    set {value = .uuColor(newValue)}
  }

  var animation: PBAnimation {
    get {
      if case .animation(let v)? = value {return v}
      return PBAnimation()
    }
    set {value = .animation(newValue)}
  }

  var ids: PBInterOptionsValue {
    get {
      if case .ids(let v)? = value {return v}
      return PBInterOptionsValue()
    }
    set {value = .ids(newValue)}
  }

  var score: PBScore {
    get {
      if case .score(let v)? = value {return v}
      return PBScore()
    }
    set {value = .score(newValue)}
  }

  var content: PBContent {
    get {
      if case .content(let v)? = value {return v}
      return PBContent()
    }
    set {value = .content(newValue)}
  }

  var image: PBImage {
    get {
      if case .image(let v)? = value {return v}
      return PBImage()
    }
    set {value = .image(newValue)}
  }

  var beatRange: PBRationalRange {
    get {
      if case .beatRange(let v)? = value {return v}
      return PBRationalRange()
    }
    set {value = .beatRange(newValue)}
  }

  var normalizationValue: Double {
    get {
      if case .normalizationValue(let v)? = value {return v}
      return 0
    }
    set {value = .normalizationValue(newValue)}
  }

  var normalizationRationalValue: PBRational {
    get {
      if case .normalizationRationalValue(let v)? = value {return v}
      return PBRational()
    }
    set {value = .normalizationRationalValue(newValue)}
  }

  var notesValue: PBNotesValue {
    get {
      if case .notesValue(let v)? = value {return v}
      return PBNotesValue()
    }
    set {value = .notesValue(newValue)}
  }

  var stereo: PBStereo {
    get {
      if case .stereo(let v)? = value {return v}
      return PBStereo()
    }
    set {value = .stereo(newValue)}
  }

  var tone: PBTone {
    get {
      if case .tone(let v)? = value {return v}
      return PBTone()
    }
    set {value = .tone(newValue)}
  }

  var envelope: PBEnvelope {
    get {
      if case .envelope(let v)? = value {return v}
      return PBEnvelope()
    }
    set {value = .envelope(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Value: Equatable, Sendable {
    case copiedSheetsValue(PBCopiedSheetsValue)
    case sheetValue(PBSheetValue)
    case border(PBBorder)
    case text(PBText)
    case string(String)
    case picture(PBPicture)
    case planesValue(PBPlanesValue)
    case uuColor(PBUUColor)
    case animation(PBAnimation)
    case ids(PBInterOptionsValue)
    case score(PBScore)
    case content(PBContent)
    case image(PBImage)
    case beatRange(PBRationalRange)
    case normalizationValue(Double)
    case normalizationRationalValue(PBRational)
    case notesValue(PBNotesValue)
    case stereo(PBStereo)
    case tone(PBTone)
    case envelope(PBEnvelope)

  }

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension PBRGBColorSpace: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "sRGB"),
    1: .same(proto: "sRGBHDR"),
    2: .same(proto: "p3"),
    3: .same(proto: "p3HDR"),
    4: .same(proto: "sRGBLinear"),
    5: .same(proto: "sRGBHDRLinear"),
    6: .same(proto: "p3Linear"),
    7: .same(proto: "p3HDRLinear"),
  ]
}

extension PBInterType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "none"),
    1: .same(proto: "key"),
    2: .same(proto: "interpolated"),
  ]
}

extension PBOrientation: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "horizontal"),
    1: .same(proto: "vertical"),
  ]
}

extension PBPreviousNext: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "off"),
    1: .same(proto: "previous"),
    2: .same(proto: "next"),
    3: .same(proto: "previousAndNext"),
  ]
}

extension PBRectCorner: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "minXMinY"),
    1: .same(proto: "minXMaxY"),
    2: .same(proto: "maxXMinY"),
    3: .same(proto: "maxXMaxY"),
  ]
}

extension PBRational: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBRational"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "p"),
    2: .same(proto: "q"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.p) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.q) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.p != 0 {
      try visitor.visitSingularInt64Field(value: self.p, fieldNumber: 1)
    }
    if self.q != 0 {
      try visitor.visitSingularInt64Field(value: self.q, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBRational, rhs: PBRational) -> Bool {
    if lhs.p != rhs.p {return false}
    if lhs.q != rhs.q {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBIntRange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBIntRange"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lowerBound"),
    2: .same(proto: "upperBound"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.lowerBound) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.upperBound) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.lowerBound != 0 {
      try visitor.visitSingularInt64Field(value: self.lowerBound, fieldNumber: 1)
    }
    if self.upperBound != 0 {
      try visitor.visitSingularInt64Field(value: self.upperBound, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBIntRange, rhs: PBIntRange) -> Bool {
    if lhs.lowerBound != rhs.lowerBound {return false}
    if lhs.upperBound != rhs.upperBound {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBRationalRange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBRationalRange"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lowerBound"),
    2: .same(proto: "upperBound"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._lowerBound) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._upperBound) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._lowerBound {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._upperBound {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBRationalRange, rhs: PBRationalRange) -> Bool {
    if lhs._lowerBound != rhs._lowerBound {return false}
    if lhs._upperBound != rhs._upperBound {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBPoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBPoint"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "x"),
    2: .same(proto: "y"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.x) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.y) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.x.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.x, fieldNumber: 1)
    }
    if self.y.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.y, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBPoint, rhs: PBPoint) -> Bool {
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBSize: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBSize"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "width"),
    2: .same(proto: "height"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.width) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.height) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.width.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.width, fieldNumber: 1)
    }
    if self.height.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.height, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBSize, rhs: PBSize) -> Bool {
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBRect: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBRect"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "origin"),
    2: .same(proto: "size"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._origin) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._size) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._origin {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._size {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBRect, rhs: PBRect) -> Bool {
    if lhs._origin != rhs._origin {return false}
    if lhs._size != rhs._size {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBAttitude: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBAttitude"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "position"),
    2: .same(proto: "scale"),
    3: .same(proto: "rotation"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._position) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._scale) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.rotation) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._position {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._scale {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.rotation.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.rotation, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBAttitude, rhs: PBAttitude) -> Bool {
    if lhs._position != rhs._position {return false}
    if lhs._scale != rhs._scale {return false}
    if lhs.rotation != rhs.rotation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBLCHA: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBLCHA"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "l"),
    2: .same(proto: "c"),
    3: .same(proto: "h"),
    4: .same(proto: "a"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.l) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.c) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.h) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.a) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.l.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.l, fieldNumber: 1)
    }
    if self.c.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.c, fieldNumber: 2)
    }
    if self.h.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.h, fieldNumber: 3)
    }
    if self.a.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.a, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBLCHA, rhs: PBLCHA) -> Bool {
    if lhs.l != rhs.l {return false}
    if lhs.c != rhs.c {return false}
    if lhs.h != rhs.h {return false}
    if lhs.a != rhs.a {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBRGBA: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBRGBA"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "r"),
    2: .same(proto: "g"),
    3: .same(proto: "b"),
    4: .same(proto: "a"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.r) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.g) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.b) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.a) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.r.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.r, fieldNumber: 1)
    }
    if self.g.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.g, fieldNumber: 2)
    }
    if self.b.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.b, fieldNumber: 3)
    }
    if self.a.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.a, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBRGBA, rhs: PBRGBA) -> Bool {
    if lhs.r != rhs.r {return false}
    if lhs.g != rhs.g {return false}
    if lhs.b != rhs.b {return false}
    if lhs.a != rhs.a {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBColor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBColor"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lcha"),
    2: .same(proto: "rgba"),
    3: .same(proto: "rgbColorSpace"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._lcha) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._rgba) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.rgbColorSpace) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._lcha {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._rgba {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.rgbColorSpace != .sRgb {
      try visitor.visitSingularEnumField(value: self.rgbColorSpace, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBColor, rhs: PBColor) -> Bool {
    if lhs._lcha != rhs._lcha {return false}
    if lhs._rgba != rhs._rgba {return false}
    if lhs.rgbColorSpace != rhs.rgbColorSpace {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBUUID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBUUID"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.value) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBUUID, rhs: PBUUID) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBUUColor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBUUColor"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBUUColor, rhs: PBUUColor) -> Bool {
    if lhs._value != rhs._value {return false}
    if lhs._id != rhs._id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBInterOption: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBInterOption"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "interType"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.interType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.interType != .none {
      try visitor.visitSingularEnumField(value: self.interType, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBInterOption, rhs: PBInterOption) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.interType != rhs.interType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBLine: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBLine"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "controls"),
    2: .same(proto: "size"),
    4: .same(proto: "id"),
    7: .same(proto: "interType"),
    6: .same(proto: "controlsData"),
    8: .same(proto: "uuColor"),
  ]

  fileprivate class _StorageClass {
    var _controls: [PBLine.PBControl] = []
    var _size: Double = 0
    var _id: PBUUID? = nil
    var _interType: PBInterType = .none
    var _controlsData: Data = Data()
    var _uuColorOptional: PBLine.OneOf_UuColorOptional?

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _controls = source._controls
      _size = source._size
      _id = source._id
      _interType = source._interType
      _controlsData = source._controlsData
      _uuColorOptional = source._uuColorOptional
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeRepeatedMessageField(value: &_storage._controls) }()
        case 2: try { try decoder.decodeSingularDoubleField(value: &_storage._size) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._id) }()
        case 6: try { try decoder.decodeSingularBytesField(value: &_storage._controlsData) }()
        case 7: try { try decoder.decodeSingularEnumField(value: &_storage._interType) }()
        case 8: try {
          var v: PBUUColor?
          var hadOneofValue = false
          if let current = _storage._uuColorOptional {
            hadOneofValue = true
            if case .uuColor(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._uuColorOptional = .uuColor(v)
          }
        }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._controls.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._controls, fieldNumber: 1)
      }
      if _storage._size.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._size, fieldNumber: 2)
      }
      try { if let v = _storage._id {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._controlsData.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._controlsData, fieldNumber: 6)
      }
      if _storage._interType != .none {
        try visitor.visitSingularEnumField(value: _storage._interType, fieldNumber: 7)
      }
      try { if case .uuColor(let v)? = _storage._uuColorOptional {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBLine, rhs: PBLine) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._controls != rhs_storage._controls {return false}
        if _storage._size != rhs_storage._size {return false}
        if _storage._id != rhs_storage._id {return false}
        if _storage._interType != rhs_storage._interType {return false}
        if _storage._controlsData != rhs_storage._controlsData {return false}
        if _storage._uuColorOptional != rhs_storage._uuColorOptional {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBLine.PBControl: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = PBLine.protoMessageName + ".PBControl"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "point"),
    2: .same(proto: "weight"),
    3: .same(proto: "pressure"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._point) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.weight) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.pressure) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._point {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.weight.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.weight, fieldNumber: 2)
    }
    if self.pressure.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.pressure, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBLine.PBControl, rhs: PBLine.PBControl) -> Bool {
    if lhs._point != rhs._point {return false}
    if lhs.weight != rhs.weight {return false}
    if lhs.pressure != rhs.pressure {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBPolygon: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBPolygon"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "points"),
    2: .same(proto: "pointsData"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.points) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.pointsData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.points.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.points, fieldNumber: 1)
    }
    if !self.pointsData.isEmpty {
      try visitor.visitSingularBytesField(value: self.pointsData, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBPolygon, rhs: PBPolygon) -> Bool {
    if lhs.points != rhs.points {return false}
    if lhs.pointsData != rhs.pointsData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBTopolygon: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBTopolygon"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "polygon"),
    2: .same(proto: "holePolygons"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._polygon) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.holePolygons) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._polygon {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.holePolygons.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.holePolygons, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBTopolygon, rhs: PBTopolygon) -> Bool {
    if lhs._polygon != rhs._polygon {return false}
    if lhs.holePolygons != rhs.holePolygons {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBPlane: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBPlane"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    4: .same(proto: "topolygon"),
    3: .same(proto: "polygon"),
    2: .same(proto: "uuColor"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._uuColor) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._polygon) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._topolygon) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._uuColor {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._polygon {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._topolygon {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBPlane, rhs: PBPlane) -> Bool {
    if lhs._topolygon != rhs._topolygon {return false}
    if lhs._polygon != rhs._polygon {return false}
    if lhs._uuColor != rhs._uuColor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBPicture: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBPicture"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lines"),
    2: .same(proto: "planes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.lines) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.planes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.lines.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.lines, fieldNumber: 1)
    }
    if !self.planes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.planes, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBPicture, rhs: PBPicture) -> Bool {
    if lhs.lines != rhs.lines {return false}
    if lhs.planes != rhs.planes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBDate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBDate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.timestamp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.timestamp.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.timestamp, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBDate, rhs: PBDate) -> Bool {
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBContentTimeOption: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBContentTimeOption"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "beatRange"),
    2: .same(proto: "localStartBeat"),
    3: .same(proto: "tempo"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._beatRange) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._localStartBeat) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._tempo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._beatRange {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._localStartBeat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._tempo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBContentTimeOption, rhs: PBContentTimeOption) -> Bool {
    if lhs._beatRange != rhs._beatRange {return false}
    if lhs._localStartBeat != rhs._localStartBeat {return false}
    if lhs._tempo != rhs._tempo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBImage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBImage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBImage, rhs: PBImage) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBStereo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBStereo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "volm"),
    2: .same(proto: "pan"),
    3: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.volm) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.pan) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.volm.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.volm, fieldNumber: 1)
    }
    if self.pan.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.pan, fieldNumber: 2)
    }
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBStereo, rhs: PBStereo) -> Bool {
    if lhs.volm != rhs.volm {return false}
    if lhs.pan != rhs.pan {return false}
    if lhs._id != rhs._id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBContent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBContent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    9: .same(proto: "directoryName"),
    1: .same(proto: "name"),
    2: .same(proto: "stereo"),
    4: .same(proto: "size"),
    5: .same(proto: "origin"),
    6: .same(proto: "isShownSpectrogram"),
    7: .same(proto: "timeOption"),
    10: .same(proto: "beat"),
    11: .same(proto: "durSec"),
    12: .same(proto: "frameRate"),
    8: .same(proto: "id"),
  ]

  fileprivate class _StorageClass {
    var _directoryName: String = String()
    var _name: String = String()
    var _stereo: PBStereo? = nil
    var _size: PBSize? = nil
    var _origin: PBPoint? = nil
    var _isShownSpectrogram: Bool = false
    var _contentTimeOptionOptional: PBContent.OneOf_ContentTimeOptionOptional?
    var _beat: PBRational? = nil
    var _durSec: PBRational? = nil
    var _frameRate: PBRational? = nil
    var _id: PBUUID? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _directoryName = source._directoryName
      _name = source._name
      _stereo = source._stereo
      _size = source._size
      _origin = source._origin
      _isShownSpectrogram = source._isShownSpectrogram
      _contentTimeOptionOptional = source._contentTimeOptionOptional
      _beat = source._beat
      _durSec = source._durSec
      _frameRate = source._frameRate
      _id = source._id
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._stereo) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._size) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._origin) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._isShownSpectrogram) }()
        case 7: try {
          var v: PBContentTimeOption?
          var hadOneofValue = false
          if let current = _storage._contentTimeOptionOptional {
            hadOneofValue = true
            if case .timeOption(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._contentTimeOptionOptional = .timeOption(v)
          }
        }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._id) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._directoryName) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._beat) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._durSec) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._frameRate) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      try { if let v = _storage._stereo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._size {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._origin {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if _storage._isShownSpectrogram != false {
        try visitor.visitSingularBoolField(value: _storage._isShownSpectrogram, fieldNumber: 6)
      }
      try { if case .timeOption(let v)? = _storage._contentTimeOptionOptional {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._id {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if !_storage._directoryName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._directoryName, fieldNumber: 9)
      }
      try { if let v = _storage._beat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._durSec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._frameRate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBContent, rhs: PBContent) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._directoryName != rhs_storage._directoryName {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._stereo != rhs_storage._stereo {return false}
        if _storage._size != rhs_storage._size {return false}
        if _storage._origin != rhs_storage._origin {return false}
        if _storage._isShownSpectrogram != rhs_storage._isShownSpectrogram {return false}
        if _storage._contentTimeOptionOptional != rhs_storage._contentTimeOptionOptional {return false}
        if _storage._beat != rhs_storage._beat {return false}
        if _storage._durSec != rhs_storage._durSec {return false}
        if _storage._frameRate != rhs_storage._frameRate {return false}
        if _storage._id != rhs_storage._id {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBOvertone: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBOvertone"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "evenVolm"),
    2: .same(proto: "oddVolm"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.evenVolm) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.oddVolm) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.evenVolm.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.evenVolm, fieldNumber: 1)
    }
    if self.oddVolm.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.oddVolm, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBOvertone, rhs: PBOvertone) -> Bool {
    if lhs.evenVolm != rhs.evenVolm {return false}
    if lhs.oddVolm != rhs.oddVolm {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBSprol: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBSprol"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pitch"),
    2: .same(proto: "volm"),
    3: .same(proto: "noise"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.pitch) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.volm) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.noise) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pitch.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.pitch, fieldNumber: 1)
    }
    if self.volm.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.volm, fieldNumber: 2)
    }
    if self.noise.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.noise, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBSprol, rhs: PBSprol) -> Bool {
    if lhs.pitch != rhs.pitch {return false}
    if lhs.volm != rhs.volm {return false}
    if lhs.noise != rhs.noise {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBSpectlope: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBSpectlope"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sprols"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.sprols) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sprols.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sprols, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBSpectlope, rhs: PBSpectlope) -> Bool {
    if lhs.sprols != rhs.sprols {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBTone: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBTone"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "overtone"),
    2: .same(proto: "spectlope"),
    4: .same(proto: "color"),
    3: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._overtone) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._spectlope) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._color) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._overtone {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._spectlope {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._color {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBTone, rhs: PBTone) -> Bool {
    if lhs._overtone != rhs._overtone {return false}
    if lhs._spectlope != rhs._spectlope {return false}
    if lhs._color != rhs._color {return false}
    if lhs._id != rhs._id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBPit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBPit"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "beat"),
    2: .same(proto: "pitch"),
    3: .same(proto: "stereo"),
    4: .same(proto: "tone"),
    5: .same(proto: "lyric"),
  ]

  fileprivate class _StorageClass {
    var _beat: PBRational? = nil
    var _pitch: PBRational? = nil
    var _stereo: PBStereo? = nil
    var _tone: PBTone? = nil
    var _lyric: String = String()

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _beat = source._beat
      _pitch = source._pitch
      _stereo = source._stereo
      _tone = source._tone
      _lyric = source._lyric
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._beat) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._pitch) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._stereo) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._tone) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._lyric) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._beat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._pitch {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._stereo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._tone {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._lyric.isEmpty {
        try visitor.visitSingularStringField(value: _storage._lyric, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBPit, rhs: PBPit) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._beat != rhs_storage._beat {return false}
        if _storage._pitch != rhs_storage._pitch {return false}
        if _storage._stereo != rhs_storage._stereo {return false}
        if _storage._tone != rhs_storage._tone {return false}
        if _storage._lyric != rhs_storage._lyric {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBPitbend: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBPitbend"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pits"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.pits) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pits.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pits, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBPitbend, rhs: PBPitbend) -> Bool {
    if lhs.pits != rhs.pits {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBReverb: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBReverb"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "earlyRSec"),
    2: .same(proto: "earlyRVolm"),
    3: .same(proto: "lateRSec"),
    4: .same(proto: "lateRVolm"),
    5: .same(proto: "releaseSec"),
    6: .same(proto: "seedID"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.earlyRsec) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.earlyRvolm) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.lateRsec) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.lateRvolm) }()
      case 5: try { try decoder.decodeSingularDoubleField(value: &self.releaseSec) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._seedID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.earlyRsec.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.earlyRsec, fieldNumber: 1)
    }
    if self.earlyRvolm.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.earlyRvolm, fieldNumber: 2)
    }
    if self.lateRsec.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.lateRsec, fieldNumber: 3)
    }
    if self.lateRvolm.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.lateRvolm, fieldNumber: 4)
    }
    if self.releaseSec.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.releaseSec, fieldNumber: 5)
    }
    try { if let v = self._seedID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBReverb, rhs: PBReverb) -> Bool {
    if lhs.earlyRsec != rhs.earlyRsec {return false}
    if lhs.earlyRvolm != rhs.earlyRvolm {return false}
    if lhs.lateRsec != rhs.lateRsec {return false}
    if lhs.lateRvolm != rhs.lateRvolm {return false}
    if lhs.releaseSec != rhs.releaseSec {return false}
    if lhs._seedID != rhs._seedID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBEnvelope: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBEnvelope"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "attackSec"),
    2: .same(proto: "decaySec"),
    3: .same(proto: "sustainVolm"),
    4: .same(proto: "releaseSec"),
    6: .same(proto: "reverb"),
    5: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.attackSec) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.decaySec) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.sustainVolm) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.releaseSec) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._reverb) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.attackSec.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.attackSec, fieldNumber: 1)
    }
    if self.decaySec.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.decaySec, fieldNumber: 2)
    }
    if self.sustainVolm.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.sustainVolm, fieldNumber: 3)
    }
    if self.releaseSec.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.releaseSec, fieldNumber: 4)
    }
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._reverb {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBEnvelope, rhs: PBEnvelope) -> Bool {
    if lhs.attackSec != rhs.attackSec {return false}
    if lhs.decaySec != rhs.decaySec {return false}
    if lhs.sustainVolm != rhs.sustainVolm {return false}
    if lhs.releaseSec != rhs.releaseSec {return false}
    if lhs._reverb != rhs._reverb {return false}
    if lhs._id != rhs._id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBNote: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBNote"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pitch"),
    2: .same(proto: "pits"),
    3: .same(proto: "beatRange"),
    7: .same(proto: "envelope"),
    9: .same(proto: "id"),
    10: .same(proto: "isShownTone"),
  ]

  fileprivate class _StorageClass {
    var _pitch: PBRational? = nil
    var _pits: [PBPit] = []
    var _beatRange: PBRationalRange? = nil
    var _envelope: PBEnvelope? = nil
    var _id: PBUUID? = nil
    var _isShownTone: Bool = false

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _pitch = source._pitch
      _pits = source._pits
      _beatRange = source._beatRange
      _envelope = source._envelope
      _id = source._id
      _isShownTone = source._isShownTone
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._pitch) }()
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._pits) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._beatRange) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._envelope) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._id) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._isShownTone) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._pitch {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if !_storage._pits.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._pits, fieldNumber: 2)
      }
      try { if let v = _storage._beatRange {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._envelope {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._id {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      if _storage._isShownTone != false {
        try visitor.visitSingularBoolField(value: _storage._isShownTone, fieldNumber: 10)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBNote, rhs: PBNote) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._pitch != rhs_storage._pitch {return false}
        if _storage._pits != rhs_storage._pits {return false}
        if _storage._beatRange != rhs_storage._beatRange {return false}
        if _storage._envelope != rhs_storage._envelope {return false}
        if _storage._id != rhs_storage._id {return false}
        if _storage._isShownTone != rhs_storage._isShownTone {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBScoreOption: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBScoreOption"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "durBeat"),
    2: .same(proto: "tempo"),
    4: .same(proto: "keyBeats"),
    3: .same(proto: "enabled"),
    5: .same(proto: "isShownSpectrogram"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._durBeat) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._tempo) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.keyBeats) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.isShownSpectrogram) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._durBeat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._tempo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 3)
    }
    if !self.keyBeats.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.keyBeats, fieldNumber: 4)
    }
    if self.isShownSpectrogram != false {
      try visitor.visitSingularBoolField(value: self.isShownSpectrogram, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBScoreOption, rhs: PBScoreOption) -> Bool {
    if lhs._durBeat != rhs._durBeat {return false}
    if lhs._tempo != rhs._tempo {return false}
    if lhs.keyBeats != rhs.keyBeats {return false}
    if lhs.enabled != rhs.enabled {return false}
    if lhs.isShownSpectrogram != rhs.isShownSpectrogram {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBScore: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBScore"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "notes"),
    6: .same(proto: "draftNotes"),
    2: .same(proto: "durBeat"),
    3: .same(proto: "tempo"),
    7: .same(proto: "keyBeats"),
    4: .same(proto: "enabled"),
    8: .same(proto: "isShownSpectrogram"),
    5: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.notes) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._durBeat) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._tempo) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.draftNotes) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.keyBeats) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.isShownSpectrogram) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.notes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.notes, fieldNumber: 1)
    }
    try { if let v = self._durBeat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._tempo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 4)
    }
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.draftNotes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.draftNotes, fieldNumber: 6)
    }
    if !self.keyBeats.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.keyBeats, fieldNumber: 7)
    }
    if self.isShownSpectrogram != false {
      try visitor.visitSingularBoolField(value: self.isShownSpectrogram, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBScore, rhs: PBScore) -> Bool {
    if lhs.notes != rhs.notes {return false}
    if lhs.draftNotes != rhs.draftNotes {return false}
    if lhs._durBeat != rhs._durBeat {return false}
    if lhs._tempo != rhs._tempo {return false}
    if lhs.keyBeats != rhs.keyBeats {return false}
    if lhs.enabled != rhs.enabled {return false}
    if lhs.isShownSpectrogram != rhs.isShownSpectrogram {return false}
    if lhs._id != rhs._id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBAudio: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBAudio"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pcmData"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.pcmData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pcmData.isEmpty {
      try visitor.visitSingularBytesField(value: self.pcmData, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBAudio, rhs: PBAudio) -> Bool {
    if lhs.pcmData != rhs.pcmData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBLocale: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBLocale"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "identifier"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.identifier) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.identifier.isEmpty {
      try visitor.visitSingularStringField(value: self.identifier, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBLocale, rhs: PBLocale) -> Bool {
    if lhs.identifier != rhs.identifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBTextTimeOption: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBTextTimeOption"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "beatRange"),
    2: .same(proto: "tempo"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._beatRange) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._tempo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._beatRange {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._tempo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBTextTimeOption, rhs: PBTextTimeOption) -> Bool {
    if lhs._beatRange != rhs._beatRange {return false}
    if lhs._tempo != rhs._tempo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBText: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBText"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "string"),
    2: .same(proto: "orientation"),
    3: .same(proto: "size"),
    4: .same(proto: "widthCount"),
    5: .same(proto: "origin"),
    7: .same(proto: "locale"),
    8: .same(proto: "timeOption"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.string) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.orientation) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.size) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.widthCount) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._origin) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._locale) }()
      case 8: try {
        var v: PBTextTimeOption?
        var hadOneofValue = false
        if let current = self.timeOptionOptional {
          hadOneofValue = true
          if case .timeOption(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.timeOptionOptional = .timeOption(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.string.isEmpty {
      try visitor.visitSingularStringField(value: self.string, fieldNumber: 1)
    }
    if self.orientation != .horizontal {
      try visitor.visitSingularEnumField(value: self.orientation, fieldNumber: 2)
    }
    if self.size.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.size, fieldNumber: 3)
    }
    if self.widthCount.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.widthCount, fieldNumber: 4)
    }
    try { if let v = self._origin {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._locale {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if case .timeOption(let v)? = self.timeOptionOptional {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBText, rhs: PBText) -> Bool {
    if lhs.string != rhs.string {return false}
    if lhs.orientation != rhs.orientation {return false}
    if lhs.size != rhs.size {return false}
    if lhs.widthCount != rhs.widthCount {return false}
    if lhs._origin != rhs._origin {return false}
    if lhs._locale != rhs._locale {return false}
    if lhs.timeOptionOptional != rhs.timeOptionOptional {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBBorder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBBorder"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "location"),
    2: .same(proto: "orientation"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.location) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.orientation) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.location.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.location, fieldNumber: 1)
    }
    if self.orientation != .horizontal {
      try visitor.visitSingularEnumField(value: self.orientation, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBBorder, rhs: PBBorder) -> Bool {
    if lhs.location != rhs.location {return false}
    if lhs.orientation != rhs.orientation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBSheetposStringDic: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBSheetposStringDic"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,PBSheetpos>.self, value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,PBSheetpos>.self, value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBSheetposStringDic, rhs: PBSheetposStringDic) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBStringIntPointDicElement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBStringIntPointDicElement"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._key) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._key {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBStringIntPointDicElement, rhs: PBStringIntPointDicElement) -> Bool {
    if lhs._key != rhs._key {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBStringIntPointDic: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBStringIntPointDic"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBStringIntPointDic, rhs: PBStringIntPointDic) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBKeyframe: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBKeyframe"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "picture"),
    2: .same(proto: "draftPicture"),
    3: .same(proto: "beat"),
    4: .same(proto: "previousNext"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._picture) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._draftPicture) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._beat) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.previousNext) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._picture {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._draftPicture {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._beat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.previousNext != .off {
      try visitor.visitSingularEnumField(value: self.previousNext, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBKeyframe, rhs: PBKeyframe) -> Bool {
    if lhs._picture != rhs._picture {return false}
    if lhs._draftPicture != rhs._draftPicture {return false}
    if lhs._beat != rhs._beat {return false}
    if lhs.previousNext != rhs.previousNext {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBKeyframeKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBKeyframeKey"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lineIs"),
    2: .same(proto: "planeIs"),
    3: .same(proto: "draftLineIs"),
    4: .same(proto: "draftPlaneIs"),
    5: .same(proto: "beat"),
    6: .same(proto: "previousNext"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedInt64Field(value: &self.lineIs) }()
      case 2: try { try decoder.decodeRepeatedInt64Field(value: &self.planeIs) }()
      case 3: try { try decoder.decodeRepeatedInt64Field(value: &self.draftLineIs) }()
      case 4: try { try decoder.decodeRepeatedInt64Field(value: &self.draftPlaneIs) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._beat) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.previousNext) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.lineIs.isEmpty {
      try visitor.visitPackedInt64Field(value: self.lineIs, fieldNumber: 1)
    }
    if !self.planeIs.isEmpty {
      try visitor.visitPackedInt64Field(value: self.planeIs, fieldNumber: 2)
    }
    if !self.draftLineIs.isEmpty {
      try visitor.visitPackedInt64Field(value: self.draftLineIs, fieldNumber: 3)
    }
    if !self.draftPlaneIs.isEmpty {
      try visitor.visitPackedInt64Field(value: self.draftPlaneIs, fieldNumber: 4)
    }
    try { if let v = self._beat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if self.previousNext != .off {
      try visitor.visitSingularEnumField(value: self.previousNext, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBKeyframeKey, rhs: PBKeyframeKey) -> Bool {
    if lhs.lineIs != rhs.lineIs {return false}
    if lhs.planeIs != rhs.planeIs {return false}
    if lhs.draftLineIs != rhs.draftLineIs {return false}
    if lhs.draftPlaneIs != rhs.draftPlaneIs {return false}
    if lhs._beat != rhs._beat {return false}
    if lhs.previousNext != rhs.previousNext {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBAnimationZipper: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBAnimationZipper"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "keys"),
    2: .same(proto: "lines"),
    3: .same(proto: "planes"),
    4: .same(proto: "draftLines"),
    5: .same(proto: "draftPlanes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.keys) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.lines) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.planes) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.draftLines) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.draftPlanes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.keys, fieldNumber: 1)
    }
    if !self.lines.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.lines, fieldNumber: 2)
    }
    if !self.planes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.planes, fieldNumber: 3)
    }
    if !self.draftLines.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.draftLines, fieldNumber: 4)
    }
    if !self.draftPlanes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.draftPlanes, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBAnimationZipper, rhs: PBAnimationZipper) -> Bool {
    if lhs.keys != rhs.keys {return false}
    if lhs.lines != rhs.lines {return false}
    if lhs.planes != rhs.planes {return false}
    if lhs.draftLines != rhs.draftLines {return false}
    if lhs.draftPlanes != rhs.draftPlanes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBAnimationOption: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBAnimationOption"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "beatRange"),
    2: .same(proto: "tempo"),
    3: .same(proto: "timelineY"),
    4: .same(proto: "enabled"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._beatRange) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._tempo) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.timelineY) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._beatRange {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._tempo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.timelineY.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.timelineY, fieldNumber: 3)
    }
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBAnimationOption, rhs: PBAnimationOption) -> Bool {
    if lhs._beatRange != rhs._beatRange {return false}
    if lhs._tempo != rhs._tempo {return false}
    if lhs.timelineY != rhs.timelineY {return false}
    if lhs.enabled != rhs.enabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBAnimation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBAnimation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "keyframes"),
    8: .same(proto: "zipper"),
    2: .same(proto: "rootBeat"),
    3: .same(proto: "beatRange"),
    4: .same(proto: "tempo"),
    5: .same(proto: "isPlaying"),
    6: .same(proto: "timelineY"),
    7: .same(proto: "enabled"),
  ]

  fileprivate class _StorageClass {
    var _keyframes: [PBKeyframe] = []
    var _zipper: PBAnimationZipper? = nil
    var _rootBeat: PBRational? = nil
    var _beatRange: PBRationalRange? = nil
    var _tempo: PBRational? = nil
    var _isPlaying: Bool = false
    var _timelineY: Double = 0
    var _enabled: Bool = false

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _keyframes = source._keyframes
      _zipper = source._zipper
      _rootBeat = source._rootBeat
      _beatRange = source._beatRange
      _tempo = source._tempo
      _isPlaying = source._isPlaying
      _timelineY = source._timelineY
      _enabled = source._enabled
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeRepeatedMessageField(value: &_storage._keyframes) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._rootBeat) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._beatRange) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._tempo) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._isPlaying) }()
        case 6: try { try decoder.decodeSingularDoubleField(value: &_storage._timelineY) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._enabled) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._zipper) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._keyframes.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._keyframes, fieldNumber: 1)
      }
      try { if let v = _storage._rootBeat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._beatRange {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._tempo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if _storage._isPlaying != false {
        try visitor.visitSingularBoolField(value: _storage._isPlaying, fieldNumber: 5)
      }
      if _storage._timelineY.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._timelineY, fieldNumber: 6)
      }
      if _storage._enabled != false {
        try visitor.visitSingularBoolField(value: _storage._enabled, fieldNumber: 7)
      }
      try { if let v = _storage._zipper {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBAnimation, rhs: PBAnimation) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._keyframes != rhs_storage._keyframes {return false}
        if _storage._zipper != rhs_storage._zipper {return false}
        if _storage._rootBeat != rhs_storage._rootBeat {return false}
        if _storage._beatRange != rhs_storage._beatRange {return false}
        if _storage._tempo != rhs_storage._tempo {return false}
        if _storage._isPlaying != rhs_storage._isPlaying {return false}
        if _storage._timelineY != rhs_storage._timelineY {return false}
        if _storage._enabled != rhs_storage._enabled {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBSheetOption: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBSheetOption"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "durBeat"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._durBeat) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._durBeat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBSheetOption, rhs: PBSheetOption) -> Bool {
    if lhs._durBeat != rhs._durBeat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBSheet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBSheet"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    6: .same(proto: "animation"),
    10: .same(proto: "score"),
    1: .same(proto: "picture"),
    2: .same(proto: "draftPicture"),
    3: .same(proto: "texts"),
    11: .same(proto: "contents"),
    4: .same(proto: "borders"),
    9: .same(proto: "rects"),
    5: .same(proto: "backgroundUUColor"),
  ]

  fileprivate class _StorageClass {
    var _animation: PBAnimation? = nil
    var _score: PBScore? = nil
    var _picture: PBPicture? = nil
    var _draftPicture: PBPicture? = nil
    var _texts: [PBText] = []
    var _contents: [PBContent] = []
    var _borders: [PBBorder] = []
    var _rects: [PBRect] = []
    var _backgroundUucolor: PBUUColor? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _animation = source._animation
      _score = source._score
      _picture = source._picture
      _draftPicture = source._draftPicture
      _texts = source._texts
      _contents = source._contents
      _borders = source._borders
      _rects = source._rects
      _backgroundUucolor = source._backgroundUucolor
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._picture) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._draftPicture) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._texts) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._borders) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._backgroundUucolor) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._animation) }()
        case 9: try { try decoder.decodeRepeatedMessageField(value: &_storage._rects) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._score) }()
        case 11: try { try decoder.decodeRepeatedMessageField(value: &_storage._contents) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._picture {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._draftPicture {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._texts.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._texts, fieldNumber: 3)
      }
      if !_storage._borders.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._borders, fieldNumber: 4)
      }
      try { if let v = _storage._backgroundUucolor {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._animation {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if !_storage._rects.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._rects, fieldNumber: 9)
      }
      try { if let v = _storage._score {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      if !_storage._contents.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._contents, fieldNumber: 11)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBSheet, rhs: PBSheet) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._animation != rhs_storage._animation {return false}
        if _storage._score != rhs_storage._score {return false}
        if _storage._picture != rhs_storage._picture {return false}
        if _storage._draftPicture != rhs_storage._draftPicture {return false}
        if _storage._texts != rhs_storage._texts {return false}
        if _storage._contents != rhs_storage._contents {return false}
        if _storage._borders != rhs_storage._borders {return false}
        if _storage._rects != rhs_storage._rects {return false}
        if _storage._backgroundUucolor != rhs_storage._backgroundUucolor {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBSheetpos: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBSheetpos"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "x"),
    2: .same(proto: "y"),
    3: .same(proto: "isRight"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.x) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.y) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isRight) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.x != 0 {
      try visitor.visitSingularInt64Field(value: self.x, fieldNumber: 1)
    }
    if self.y != 0 {
      try visitor.visitSingularInt64Field(value: self.y, fieldNumber: 2)
    }
    if self.isRight != false {
      try visitor.visitSingularBoolField(value: self.isRight, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBSheetpos, rhs: PBSheetpos) -> Bool {
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.isRight != rhs.isRight {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBWorld: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBWorld"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sheetPositions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._sheetPositions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._sheetPositions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBWorld, rhs: PBWorld) -> Bool {
    if lhs._sheetPositions != rhs._sheetPositions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBCornerRectValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBCornerRectValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rect"),
    2: .same(proto: "rectCorner"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._rect) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.rectCorner) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._rect {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.rectCorner != .minXminY {
      try visitor.visitSingularEnumField(value: self.rectCorner, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBCornerRectValue, rhs: PBCornerRectValue) -> Bool {
    if lhs._rect != rhs._rect {return false}
    if lhs.rectCorner != rhs.rectCorner {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBCornerRectValueArray: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBCornerRectValueArray"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBCornerRectValueArray, rhs: PBCornerRectValueArray) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBFinding: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBFinding"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "worldPosition"),
    2: .same(proto: "string"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._worldPosition) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.string) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._worldPosition {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.string.isEmpty {
      try visitor.visitSingularStringField(value: self.string, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBFinding, rhs: PBFinding) -> Bool {
    if lhs._worldPosition != rhs._worldPosition {return false}
    if lhs.string != rhs.string {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBKeyframeOption: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBKeyframeOption"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "beat"),
    2: .same(proto: "previousNext"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._beat) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.previousNext) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._beat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.previousNext != .off {
      try visitor.visitSingularEnumField(value: self.previousNext, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBKeyframeOption, rhs: PBKeyframeOption) -> Bool {
    if lhs._beat != rhs._beat {return false}
    if lhs.previousNext != rhs.previousNext {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBBoolIndexValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBBoolIndexValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "index"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.value) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.index) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != false {
      try visitor.visitSingularBoolField(value: self.value, fieldNumber: 1)
    }
    if self.index != 0 {
      try visitor.visitSingularInt64Field(value: self.index, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBBoolIndexValue, rhs: PBBoolIndexValue) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.index != rhs.index {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBIntIndexValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBIntIndexValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "index"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.value) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.index) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularInt64Field(value: self.value, fieldNumber: 1)
    }
    if self.index != 0 {
      try visitor.visitSingularInt64Field(value: self.index, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBIntIndexValue, rhs: PBIntIndexValue) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.index != rhs.index {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBLineIndexValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBLineIndexValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "index"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.index) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.index != 0 {
      try visitor.visitSingularInt64Field(value: self.index, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBLineIndexValue, rhs: PBLineIndexValue) -> Bool {
    if lhs._value != rhs._value {return false}
    if lhs.index != rhs.index {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBInterOptionIndexValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBInterOptionIndexValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "index"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.index) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.index != 0 {
      try visitor.visitSingularInt64Field(value: self.index, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBInterOptionIndexValue, rhs: PBInterOptionIndexValue) -> Bool {
    if lhs._value != rhs._value {return false}
    if lhs.index != rhs.index {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBPlaneIndexValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBPlaneIndexValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "index"),
  ]

  fileprivate class _StorageClass {
    var _value: PBPlane? = nil
    var _index: Int64 = 0

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _value = source._value
      _index = source._index
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._value) }()
        case 2: try { try decoder.decodeSingularInt64Field(value: &_storage._index) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._value {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if _storage._index != 0 {
        try visitor.visitSingularInt64Field(value: _storage._index, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBPlaneIndexValue, rhs: PBPlaneIndexValue) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._value != rhs_storage._value {return false}
        if _storage._index != rhs_storage._index {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBTextIndexValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBTextIndexValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "index"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.index) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.index != 0 {
      try visitor.visitSingularInt64Field(value: self.index, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBTextIndexValue, rhs: PBTextIndexValue) -> Bool {
    if lhs._value != rhs._value {return false}
    if lhs.index != rhs.index {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBNoteIndexValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBNoteIndexValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "index"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.index) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.index != 0 {
      try visitor.visitSingularInt64Field(value: self.index, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBNoteIndexValue, rhs: PBNoteIndexValue) -> Bool {
    if lhs._value != rhs._value {return false}
    if lhs.index != rhs.index {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBContentIndexValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBContentIndexValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "index"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.index) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.index != 0 {
      try visitor.visitSingularInt64Field(value: self.index, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBContentIndexValue, rhs: PBContentIndexValue) -> Bool {
    if lhs._value != rhs._value {return false}
    if lhs.index != rhs.index {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBBorderIndexValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBBorderIndexValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "index"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.index) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.index != 0 {
      try visitor.visitSingularInt64Field(value: self.index, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBBorderIndexValue, rhs: PBBorderIndexValue) -> Bool {
    if lhs._value != rhs._value {return false}
    if lhs.index != rhs.index {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBKeyframeIndexValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBKeyframeIndexValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "index"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.index) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.index != 0 {
      try visitor.visitSingularInt64Field(value: self.index, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBKeyframeIndexValue, rhs: PBKeyframeIndexValue) -> Bool {
    if lhs._value != rhs._value {return false}
    if lhs.index != rhs.index {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBKeyframeOptionIndexValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBKeyframeOptionIndexValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "index"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.index) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.index != 0 {
      try visitor.visitSingularInt64Field(value: self.index, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBKeyframeOptionIndexValue, rhs: PBKeyframeOptionIndexValue) -> Bool {
    if lhs._value != rhs._value {return false}
    if lhs.index != rhs.index {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBColorValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBColorValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuColor"),
    3: .same(proto: "planeIndexes"),
    8: .same(proto: "lineIndexes"),
    6: .same(proto: "planeAnimationIndexes"),
    9: .same(proto: "lineAnimationIndexes"),
    7: .same(proto: "animationColors"),
    5: .same(proto: "isBackground"),
  ]

  fileprivate class _StorageClass {
    var _uuColor: PBUUColor? = nil
    var _planeIndexes: [Int64] = []
    var _lineIndexes: [Int64] = []
    var _planeAnimationIndexes: PBIntArrayIndexValueArray? = nil
    var _lineAnimationIndexes: PBIntArrayIndexValueArray? = nil
    var _animationColors: [PBColor] = []
    var _isBackground: Bool = false

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _uuColor = source._uuColor
      _planeIndexes = source._planeIndexes
      _lineIndexes = source._lineIndexes
      _planeAnimationIndexes = source._planeAnimationIndexes
      _lineAnimationIndexes = source._lineAnimationIndexes
      _animationColors = source._animationColors
      _isBackground = source._isBackground
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._uuColor) }()
        case 3: try { try decoder.decodeRepeatedInt64Field(value: &_storage._planeIndexes) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._isBackground) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._planeAnimationIndexes) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._animationColors) }()
        case 8: try { try decoder.decodeRepeatedInt64Field(value: &_storage._lineIndexes) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._lineAnimationIndexes) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._uuColor {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if !_storage._planeIndexes.isEmpty {
        try visitor.visitPackedInt64Field(value: _storage._planeIndexes, fieldNumber: 3)
      }
      if _storage._isBackground != false {
        try visitor.visitSingularBoolField(value: _storage._isBackground, fieldNumber: 5)
      }
      try { if let v = _storage._planeAnimationIndexes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if !_storage._animationColors.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._animationColors, fieldNumber: 7)
      }
      if !_storage._lineIndexes.isEmpty {
        try visitor.visitPackedInt64Field(value: _storage._lineIndexes, fieldNumber: 8)
      }
      try { if let v = _storage._lineAnimationIndexes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBColorValue, rhs: PBColorValue) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._uuColor != rhs_storage._uuColor {return false}
        if _storage._planeIndexes != rhs_storage._planeIndexes {return false}
        if _storage._lineIndexes != rhs_storage._lineIndexes {return false}
        if _storage._planeAnimationIndexes != rhs_storage._planeAnimationIndexes {return false}
        if _storage._lineAnimationIndexes != rhs_storage._lineAnimationIndexes {return false}
        if _storage._animationColors != rhs_storage._animationColors {return false}
        if _storage._isBackground != rhs_storage._isBackground {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBPlaneValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBPlaneValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "planes"),
    2: .same(proto: "moveIndexValues"),
    3: .same(proto: "index"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.planes) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.moveIndexValues) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.index) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.planes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.planes, fieldNumber: 1)
    }
    if !self.moveIndexValues.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.moveIndexValues, fieldNumber: 2)
    }
    if self.index != 0 {
      try visitor.visitSingularInt64Field(value: self.index, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBPlaneValue, rhs: PBPlaneValue) -> Bool {
    if lhs.planes != rhs.planes {return false}
    if lhs.moveIndexValues != rhs.moveIndexValues {return false}
    if lhs.index != rhs.index {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBTextValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBTextValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "string"),
    2: .same(proto: "replacedRange"),
    3: .same(proto: "origin"),
    4: .same(proto: "size"),
    5: .same(proto: "widthCount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.string) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._replacedRange) }()
      case 3: try {
        var v: PBPoint?
        var hadOneofValue = false
        if let current = self.originOptional {
          hadOneofValue = true
          if case .origin(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.originOptional = .origin(v)
        }
      }()
      case 4: try {
        var v: Double?
        try decoder.decodeSingularDoubleField(value: &v)
        if let v = v {
          if self.sizeOptional != nil {try decoder.handleConflictingOneOf()}
          self.sizeOptional = .size(v)
        }
      }()
      case 5: try {
        var v: Double?
        try decoder.decodeSingularDoubleField(value: &v)
        if let v = v {
          if self.widthCountOptional != nil {try decoder.handleConflictingOneOf()}
          self.widthCountOptional = .widthCount(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.string.isEmpty {
      try visitor.visitSingularStringField(value: self.string, fieldNumber: 1)
    }
    try { if let v = self._replacedRange {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if case .origin(let v)? = self.originOptional {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if case .size(let v)? = self.sizeOptional {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 4)
    } }()
    try { if case .widthCount(let v)? = self.widthCountOptional {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBTextValue, rhs: PBTextValue) -> Bool {
    if lhs.string != rhs.string {return false}
    if lhs._replacedRange != rhs._replacedRange {return false}
    if lhs.originOptional != rhs.originOptional {return false}
    if lhs.sizeOptional != rhs.sizeOptional {return false}
    if lhs.widthCountOptional != rhs.widthCountOptional {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBTextValueIndexValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBTextValueIndexValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "index"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.index) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.index != 0 {
      try visitor.visitSingularInt64Field(value: self.index, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBTextValueIndexValue, rhs: PBTextValueIndexValue) -> Bool {
    if lhs._value != rhs._value {return false}
    if lhs.index != rhs.index {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBSheetValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBSheetValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lines"),
    2: .same(proto: "planes"),
    3: .same(proto: "texts"),
    4: .same(proto: "origin"),
    5: .same(proto: "id"),
    6: .same(proto: "rootKeyframeIndex"),
    7: .same(proto: "keyframes"),
    8: .same(proto: "keyframeBeganIndex"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.lines) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.planes) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.texts) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._origin) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.rootKeyframeIndex) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.keyframes) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.keyframeBeganIndex) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.lines.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.lines, fieldNumber: 1)
    }
    if !self.planes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.planes, fieldNumber: 2)
    }
    if !self.texts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.texts, fieldNumber: 3)
    }
    try { if let v = self._origin {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if self.rootKeyframeIndex != 0 {
      try visitor.visitSingularInt64Field(value: self.rootKeyframeIndex, fieldNumber: 6)
    }
    if !self.keyframes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.keyframes, fieldNumber: 7)
    }
    if self.keyframeBeganIndex != 0 {
      try visitor.visitSingularInt64Field(value: self.keyframeBeganIndex, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBSheetValue, rhs: PBSheetValue) -> Bool {
    if lhs.lines != rhs.lines {return false}
    if lhs.planes != rhs.planes {return false}
    if lhs.texts != rhs.texts {return false}
    if lhs._origin != rhs._origin {return false}
    if lhs._id != rhs._id {return false}
    if lhs.rootKeyframeIndex != rhs.rootKeyframeIndex {return false}
    if lhs.keyframes != rhs.keyframes {return false}
    if lhs.keyframeBeganIndex != rhs.keyframeBeganIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBInt64Array: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBInt64Array"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedInt64Field(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitPackedInt64Field(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBInt64Array, rhs: PBInt64Array) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBIntArrayIndexValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBIntArrayIndexValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "index"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.index) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.index != 0 {
      try visitor.visitSingularInt64Field(value: self.index, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBIntArrayIndexValue, rhs: PBIntArrayIndexValue) -> Bool {
    if lhs._value != rhs._value {return false}
    if lhs.index != rhs.index {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBIntArrayIndexValueArray: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBIntArrayIndexValueArray"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBIntArrayIndexValueArray, rhs: PBIntArrayIndexValueArray) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBLineArray: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBLineArray"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBLineArray, rhs: PBLineArray) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBPlaneArray: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBPlaneArray"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBPlaneArray, rhs: PBPlaneArray) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBSheetposArray: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBSheetposArray"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBSheetposArray, rhs: PBSheetposArray) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBIntIndexValueArray: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBIntIndexValueArray"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBIntIndexValueArray, rhs: PBIntIndexValueArray) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBLineIndexValueArray: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBLineIndexValueArray"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBLineIndexValueArray, rhs: PBLineIndexValueArray) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBLineIndexValueArrayIndexValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBLineIndexValueArrayIndexValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "index"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.value) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.index) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.value, fieldNumber: 1)
    }
    if self.index != 0 {
      try visitor.visitSingularInt64Field(value: self.index, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBLineIndexValueArrayIndexValue, rhs: PBLineIndexValueArrayIndexValue) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.index != rhs.index {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBLineIndexValueArrayIndexValueArray: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBLineIndexValueArrayIndexValueArray"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBLineIndexValueArrayIndexValueArray, rhs: PBLineIndexValueArrayIndexValueArray) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBPlaneIndexValueArrayIndexValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBPlaneIndexValueArrayIndexValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "index"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.value) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.index) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.value, fieldNumber: 1)
    }
    if self.index != 0 {
      try visitor.visitSingularInt64Field(value: self.index, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBPlaneIndexValueArrayIndexValue, rhs: PBPlaneIndexValueArrayIndexValue) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.index != rhs.index {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBPlaneIndexValueArrayIndexValueArray: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBPlaneIndexValueArrayIndexValueArray"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBPlaneIndexValueArrayIndexValueArray, rhs: PBPlaneIndexValueArrayIndexValueArray) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBInterOptionIndexValueArray: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBInterOptionIndexValueArray"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBInterOptionIndexValueArray, rhs: PBInterOptionIndexValueArray) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBInterOptionIndexValueArrayIndexValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBInterOptionIndexValueArrayIndexValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "index"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.value) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.index) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.value, fieldNumber: 1)
    }
    if self.index != 0 {
      try visitor.visitSingularInt64Field(value: self.index, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBInterOptionIndexValueArrayIndexValue, rhs: PBInterOptionIndexValueArrayIndexValue) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.index != rhs.index {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBInterOptionIndexValueArrayIndexValueArray: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBInterOptionIndexValueArrayIndexValueArray"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBInterOptionIndexValueArrayIndexValueArray, rhs: PBInterOptionIndexValueArrayIndexValueArray) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBBoolIndexValueArray: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBBoolIndexValueArray"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBBoolIndexValueArray, rhs: PBBoolIndexValueArray) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBPlaneIndexValueArray: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBPlaneIndexValueArray"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBPlaneIndexValueArray, rhs: PBPlaneIndexValueArray) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBNoteIndexValueArray: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBNoteIndexValueArray"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBNoteIndexValueArray, rhs: PBNoteIndexValueArray) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBTextIndexValueArray: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBTextIndexValueArray"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBTextIndexValueArray, rhs: PBTextIndexValueArray) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBContentIndexValueArray: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBContentIndexValueArray"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBContentIndexValueArray, rhs: PBContentIndexValueArray) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBBorderIndexValueArray: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBBorderIndexValueArray"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBBorderIndexValueArray, rhs: PBBorderIndexValueArray) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBKeyframeIndexValueArray: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBKeyframeIndexValueArray"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBKeyframeIndexValueArray, rhs: PBKeyframeIndexValueArray) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBKeyframeOptionIndexValueArray: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBKeyframeOptionIndexValueArray"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBKeyframeOptionIndexValueArray, rhs: PBKeyframeOptionIndexValueArray) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBSheetUndoItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBSheetUndoItem"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "appendLine"),
    2: .same(proto: "appendLines"),
    3: .same(proto: "appendPlanes"),
    4: .same(proto: "removeLastLines"),
    5: .same(proto: "removeLastPlanes"),
    6: .same(proto: "insertLines"),
    7: .same(proto: "insertPlanes"),
    8: .same(proto: "removeLines"),
    9: .same(proto: "removePlanes"),
    10: .same(proto: "setPlaneValue"),
    11: .same(proto: "changeToDraft"),
    12: .same(proto: "setPicture"),
    13: .same(proto: "insertDraftLines"),
    14: .same(proto: "insertDraftPlanes"),
    15: .same(proto: "removeDraftLines"),
    16: .same(proto: "removeDraftPlanes"),
    17: .same(proto: "setDraftPicture"),
    18: .same(proto: "insertTexts"),
    19: .same(proto: "removeTexts"),
    20: .same(proto: "replaceString"),
    21: .same(proto: "changedColors"),
    22: .same(proto: "insertBorders"),
    23: .same(proto: "removeBorders"),
    24: .same(proto: "setRootKeyframeIndex"),
    25: .same(proto: "insertKeyframes"),
    26: .same(proto: "removeKeyframes"),
    27: .same(proto: "setKeyframeOptions"),
    28: .same(proto: "insertKeyLines"),
    29: .same(proto: "replaceKeyLines"),
    30: .same(proto: "removeKeyLines"),
    34: .same(proto: "insertKeyPlanes"),
    41: .same(proto: "replaceKeyPlanes"),
    35: .same(proto: "removeKeyPlanes"),
    36: .same(proto: "insertDraftKeyLines"),
    37: .same(proto: "removeDraftKeyLines"),
    38: .same(proto: "insertDraftKeyPlanes"),
    39: .same(proto: "removeDraftKeyPlanes"),
    31: .same(proto: "setLineIDs"),
    40: .same(proto: "setAnimationOption"),
    42: .same(proto: "insertNotes"),
    43: .same(proto: "replaceNotes"),
    44: .same(proto: "removeNotes"),
    46: .same(proto: "insertContents"),
    47: .same(proto: "replaceContents"),
    48: .same(proto: "removeContents"),
    49: .same(proto: "setScoreOption"),
    50: .same(proto: "insertDraftNotes"),
    51: .same(proto: "removeDraftNotes"),
    52: .same(proto: "setIsShownTones"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: PBLine?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .appendLine(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .appendLine(v)
        }
      }()
      case 2: try {
        var v: PBLineArray?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .appendLines(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .appendLines(v)
        }
      }()
      case 3: try {
        var v: PBPlaneArray?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .appendPlanes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .appendPlanes(v)
        }
      }()
      case 4: try {
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .removeLastLines(v)
        }
      }()
      case 5: try {
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .removeLastPlanes(v)
        }
      }()
      case 6: try {
        var v: PBLineIndexValueArray?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .insertLines(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .insertLines(v)
        }
      }()
      case 7: try {
        var v: PBPlaneIndexValueArray?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .insertPlanes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .insertPlanes(v)
        }
      }()
      case 8: try {
        var v: PBInt64Array?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .removeLines(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .removeLines(v)
        }
      }()
      case 9: try {
        var v: PBInt64Array?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .removePlanes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .removePlanes(v)
        }
      }()
      case 10: try {
        var v: PBPlaneValue?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .setPlaneValue(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .setPlaneValue(v)
        }
      }()
      case 11: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .changeToDraft(v)
        }
      }()
      case 12: try {
        var v: PBPicture?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .setPicture(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .setPicture(v)
        }
      }()
      case 13: try {
        var v: PBLineIndexValueArray?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .insertDraftLines(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .insertDraftLines(v)
        }
      }()
      case 14: try {
        var v: PBPlaneIndexValueArray?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .insertDraftPlanes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .insertDraftPlanes(v)
        }
      }()
      case 15: try {
        var v: PBInt64Array?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .removeDraftLines(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .removeDraftLines(v)
        }
      }()
      case 16: try {
        var v: PBInt64Array?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .removeDraftPlanes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .removeDraftPlanes(v)
        }
      }()
      case 17: try {
        var v: PBPicture?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .setDraftPicture(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .setDraftPicture(v)
        }
      }()
      case 18: try {
        var v: PBTextIndexValueArray?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .insertTexts(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .insertTexts(v)
        }
      }()
      case 19: try {
        var v: PBInt64Array?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .removeTexts(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .removeTexts(v)
        }
      }()
      case 20: try {
        var v: PBTextValueIndexValue?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .replaceString(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .replaceString(v)
        }
      }()
      case 21: try {
        var v: PBColorValue?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .changedColors(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .changedColors(v)
        }
      }()
      case 22: try {
        var v: PBBorderIndexValueArray?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .insertBorders(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .insertBorders(v)
        }
      }()
      case 23: try {
        var v: PBInt64Array?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .removeBorders(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .removeBorders(v)
        }
      }()
      case 24: try {
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .setRootKeyframeIndex(v)
        }
      }()
      case 25: try {
        var v: PBKeyframeIndexValueArray?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .insertKeyframes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .insertKeyframes(v)
        }
      }()
      case 26: try {
        var v: PBInt64Array?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .removeKeyframes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .removeKeyframes(v)
        }
      }()
      case 27: try {
        var v: PBKeyframeOptionIndexValueArray?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .setKeyframeOptions(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .setKeyframeOptions(v)
        }
      }()
      case 28: try {
        var v: PBLineIndexValueArrayIndexValueArray?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .insertKeyLines(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .insertKeyLines(v)
        }
      }()
      case 29: try {
        var v: PBLineIndexValueArrayIndexValueArray?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .replaceKeyLines(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .replaceKeyLines(v)
        }
      }()
      case 30: try {
        var v: PBIntArrayIndexValueArray?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .removeKeyLines(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .removeKeyLines(v)
        }
      }()
      case 31: try {
        var v: PBInterOptionIndexValueArrayIndexValueArray?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .setLineIds(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .setLineIds(v)
        }
      }()
      case 34: try {
        var v: PBPlaneIndexValueArrayIndexValueArray?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .insertKeyPlanes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .insertKeyPlanes(v)
        }
      }()
      case 35: try {
        var v: PBIntArrayIndexValueArray?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .removeKeyPlanes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .removeKeyPlanes(v)
        }
      }()
      case 36: try {
        var v: PBLineIndexValueArrayIndexValueArray?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .insertDraftKeyLines(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .insertDraftKeyLines(v)
        }
      }()
      case 37: try {
        var v: PBIntArrayIndexValueArray?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .removeDraftKeyLines(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .removeDraftKeyLines(v)
        }
      }()
      case 38: try {
        var v: PBPlaneIndexValueArrayIndexValueArray?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .insertDraftKeyPlanes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .insertDraftKeyPlanes(v)
        }
      }()
      case 39: try {
        var v: PBIntArrayIndexValueArray?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .removeDraftKeyPlanes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .removeDraftKeyPlanes(v)
        }
      }()
      case 40: try {
        var v: PBAnimationOption?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .setAnimationOption(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .setAnimationOption(v)
        }
      }()
      case 41: try {
        var v: PBPlaneIndexValueArrayIndexValueArray?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .replaceKeyPlanes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .replaceKeyPlanes(v)
        }
      }()
      case 42: try {
        var v: PBNoteIndexValueArray?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .insertNotes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .insertNotes(v)
        }
      }()
      case 43: try {
        var v: PBNoteIndexValueArray?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .replaceNotes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .replaceNotes(v)
        }
      }()
      case 44: try {
        var v: PBInt64Array?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .removeNotes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .removeNotes(v)
        }
      }()
      case 46: try {
        var v: PBContentIndexValueArray?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .insertContents(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .insertContents(v)
        }
      }()
      case 47: try {
        var v: PBContentIndexValueArray?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .replaceContents(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .replaceContents(v)
        }
      }()
      case 48: try {
        var v: PBInt64Array?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .removeContents(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .removeContents(v)
        }
      }()
      case 49: try {
        var v: PBScoreOption?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .setScoreOption(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .setScoreOption(v)
        }
      }()
      case 50: try {
        var v: PBNoteIndexValueArray?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .insertDraftNotes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .insertDraftNotes(v)
        }
      }()
      case 51: try {
        var v: PBInt64Array?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .removeDraftNotes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .removeDraftNotes(v)
        }
      }()
      case 52: try {
        var v: PBBoolIndexValueArray?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .setIsShownTones(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .setIsShownTones(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.value {
    case .appendLine?: try {
      guard case .appendLine(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .appendLines?: try {
      guard case .appendLines(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .appendPlanes?: try {
      guard case .appendPlanes(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .removeLastLines?: try {
      guard case .removeLastLines(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 4)
    }()
    case .removeLastPlanes?: try {
      guard case .removeLastPlanes(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 5)
    }()
    case .insertLines?: try {
      guard case .insertLines(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .insertPlanes?: try {
      guard case .insertPlanes(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .removeLines?: try {
      guard case .removeLines(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .removePlanes?: try {
      guard case .removePlanes(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .setPlaneValue?: try {
      guard case .setPlaneValue(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .changeToDraft?: try {
      guard case .changeToDraft(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 11)
    }()
    case .setPicture?: try {
      guard case .setPicture(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .insertDraftLines?: try {
      guard case .insertDraftLines(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .insertDraftPlanes?: try {
      guard case .insertDraftPlanes(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .removeDraftLines?: try {
      guard case .removeDraftLines(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .removeDraftPlanes?: try {
      guard case .removeDraftPlanes(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .setDraftPicture?: try {
      guard case .setDraftPicture(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .insertTexts?: try {
      guard case .insertTexts(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case .removeTexts?: try {
      guard case .removeTexts(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    }()
    case .replaceString?: try {
      guard case .replaceString(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    }()
    case .changedColors?: try {
      guard case .changedColors(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
    }()
    case .insertBorders?: try {
      guard case .insertBorders(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
    }()
    case .removeBorders?: try {
      guard case .removeBorders(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
    }()
    case .setRootKeyframeIndex?: try {
      guard case .setRootKeyframeIndex(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 24)
    }()
    case .insertKeyframes?: try {
      guard case .insertKeyframes(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
    }()
    case .removeKeyframes?: try {
      guard case .removeKeyframes(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
    }()
    case .setKeyframeOptions?: try {
      guard case .setKeyframeOptions(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
    }()
    case .insertKeyLines?: try {
      guard case .insertKeyLines(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
    }()
    case .replaceKeyLines?: try {
      guard case .replaceKeyLines(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
    }()
    case .removeKeyLines?: try {
      guard case .removeKeyLines(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
    }()
    case .setLineIds?: try {
      guard case .setLineIds(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
    }()
    case .insertKeyPlanes?: try {
      guard case .insertKeyPlanes(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 34)
    }()
    case .removeKeyPlanes?: try {
      guard case .removeKeyPlanes(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 35)
    }()
    case .insertDraftKeyLines?: try {
      guard case .insertDraftKeyLines(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 36)
    }()
    case .removeDraftKeyLines?: try {
      guard case .removeDraftKeyLines(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 37)
    }()
    case .insertDraftKeyPlanes?: try {
      guard case .insertDraftKeyPlanes(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 38)
    }()
    case .removeDraftKeyPlanes?: try {
      guard case .removeDraftKeyPlanes(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 39)
    }()
    case .setAnimationOption?: try {
      guard case .setAnimationOption(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 40)
    }()
    case .replaceKeyPlanes?: try {
      guard case .replaceKeyPlanes(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 41)
    }()
    case .insertNotes?: try {
      guard case .insertNotes(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 42)
    }()
    case .replaceNotes?: try {
      guard case .replaceNotes(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 43)
    }()
    case .removeNotes?: try {
      guard case .removeNotes(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 44)
    }()
    case .insertContents?: try {
      guard case .insertContents(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 46)
    }()
    case .replaceContents?: try {
      guard case .replaceContents(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 47)
    }()
    case .removeContents?: try {
      guard case .removeContents(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 48)
    }()
    case .setScoreOption?: try {
      guard case .setScoreOption(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 49)
    }()
    case .insertDraftNotes?: try {
      guard case .insertDraftNotes(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 50)
    }()
    case .removeDraftNotes?: try {
      guard case .removeDraftNotes(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 51)
    }()
    case .setIsShownTones?: try {
      guard case .setIsShownTones(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 52)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBSheetUndoItem, rhs: PBSheetUndoItem) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBWorldUndoItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBWorldUndoItem"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "insertSheets"),
    2: .same(proto: "removeSheets"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: PBStringIntPointDic?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .insertSheets(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .insertSheets(v)
        }
      }()
      case 2: try {
        var v: PBSheetposArray?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .removeSheets(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .removeSheets(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.value {
    case .insertSheets?: try {
      guard case .insertSheets(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .removeSheets?: try {
      guard case .removeSheets(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBWorldUndoItem, rhs: PBWorldUndoItem) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBUndoDataValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBUndoDataValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "undoItemData"),
    2: .same(proto: "redoItemData"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.undoItemData) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.redoItemData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.undoItemData.isEmpty {
      try visitor.visitSingularBytesField(value: self.undoItemData, fieldNumber: 1)
    }
    if !self.redoItemData.isEmpty {
      try visitor.visitSingularBytesField(value: self.redoItemData, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBUndoDataValue, rhs: PBUndoDataValue) -> Bool {
    if lhs.undoItemData != rhs.undoItemData {return false}
    if lhs.redoItemData != rhs.redoItemData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBUndoGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBUndoGroup"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "values"),
    2: .same(proto: "isFirstReverse"),
    3: .same(proto: "date"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.values) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isFirstReverse) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._date) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.values.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.values, fieldNumber: 1)
    }
    if self.isFirstReverse != false {
      try visitor.visitSingularBoolField(value: self.isFirstReverse, fieldNumber: 2)
    }
    try { if let v = self._date {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBUndoGroup, rhs: PBUndoGroup) -> Bool {
    if lhs.values != rhs.values {return false}
    if lhs.isFirstReverse != rhs.isFirstReverse {return false}
    if lhs._date != rhs._date {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBBranch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBBranch"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "groups"),
    2: .same(proto: "childrenCount"),
    3: .same(proto: "selectedChildIndex"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.groups) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.childrenCount) }()
      case 3: try {
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {
          if self.selectedChildIndexOptional != nil {try decoder.handleConflictingOneOf()}
          self.selectedChildIndexOptional = .selectedChildIndex(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.groups.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.groups, fieldNumber: 1)
    }
    if self.childrenCount != 0 {
      try visitor.visitSingularInt64Field(value: self.childrenCount, fieldNumber: 2)
    }
    try { if case .selectedChildIndex(let v)? = self.selectedChildIndexOptional {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBBranch, rhs: PBBranch) -> Bool {
    if lhs.groups != rhs.groups {return false}
    if lhs.childrenCount != rhs.childrenCount {return false}
    if lhs.selectedChildIndexOptional != rhs.selectedChildIndexOptional {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBBranchCoder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBBranchCoder"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "allBranches"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.allBranches) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.allBranches.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.allBranches, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBBranchCoder, rhs: PBBranchCoder) -> Bool {
    if lhs.allBranches != rhs.allBranches {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBHistory: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBHistory"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "branchCoder"),
    2: .same(proto: "currentVersionIndex"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._branchCoder) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.currentVersionIndex) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._branchCoder {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.currentVersionIndex != 0 {
      try visitor.visitSingularInt64Field(value: self.currentVersionIndex, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBHistory, rhs: PBHistory) -> Bool {
    if lhs._branchCoder != rhs._branchCoder {return false}
    if lhs.currentVersionIndex != rhs.currentVersionIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBCopiedSheetsValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBCopiedSheetsValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "deltaPoint"),
    2: .same(proto: "sheetIDs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._deltaPoint) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._sheetIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._deltaPoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._sheetIds {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBCopiedSheetsValue, rhs: PBCopiedSheetsValue) -> Bool {
    if lhs._deltaPoint != rhs._deltaPoint {return false}
    if lhs._sheetIds != rhs._sheetIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBPlanesValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBPlanesValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "planes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.planes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.planes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.planes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBPlanesValue, rhs: PBPlanesValue) -> Bool {
    if lhs.planes != rhs.planes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBNotesValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBNotesValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "notes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.notes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.notes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.notes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBNotesValue, rhs: PBNotesValue) -> Bool {
    if lhs.notes != rhs.notes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBInterOptionsValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBInterOptionsValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ids"),
    2: .same(proto: "sheetID"),
    3: .same(proto: "rootKeyframeIndex"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.ids) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._sheetID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.rootKeyframeIndex) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.ids.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ids, fieldNumber: 1)
    }
    try { if let v = self._sheetID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.rootKeyframeIndex != 0 {
      try visitor.visitSingularInt64Field(value: self.rootKeyframeIndex, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBInterOptionsValue, rhs: PBInterOptionsValue) -> Bool {
    if lhs.ids != rhs.ids {return false}
    if lhs._sheetID != rhs._sheetID {return false}
    if lhs.rootKeyframeIndex != rhs.rootKeyframeIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBPastableObject: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PBPastableObject"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "copiedSheetsValue"),
    2: .same(proto: "sheetValue"),
    3: .same(proto: "border"),
    4: .same(proto: "text"),
    5: .same(proto: "string"),
    6: .same(proto: "picture"),
    7: .same(proto: "planesValue"),
    8: .same(proto: "uuColor"),
    9: .same(proto: "animation"),
    10: .same(proto: "ids"),
    11: .same(proto: "score"),
    22: .same(proto: "content"),
    21: .same(proto: "image"),
    12: .same(proto: "beatRange"),
    13: .same(proto: "normalizationValue"),
    16: .same(proto: "normalizationRationalValue"),
    14: .same(proto: "notesValue"),
    24: .same(proto: "stereo"),
    15: .same(proto: "tone"),
    23: .same(proto: "envelope"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: PBCopiedSheetsValue?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .copiedSheetsValue(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .copiedSheetsValue(v)
        }
      }()
      case 2: try {
        var v: PBSheetValue?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .sheetValue(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .sheetValue(v)
        }
      }()
      case 3: try {
        var v: PBBorder?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .border(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .border(v)
        }
      }()
      case 4: try {
        var v: PBText?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .text(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .text(v)
        }
      }()
      case 5: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .string(v)
        }
      }()
      case 6: try {
        var v: PBPicture?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .picture(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .picture(v)
        }
      }()
      case 7: try {
        var v: PBPlanesValue?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .planesValue(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .planesValue(v)
        }
      }()
      case 8: try {
        var v: PBUUColor?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .uuColor(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .uuColor(v)
        }
      }()
      case 9: try {
        var v: PBAnimation?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .animation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .animation(v)
        }
      }()
      case 10: try {
        var v: PBInterOptionsValue?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .ids(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .ids(v)
        }
      }()
      case 11: try {
        var v: PBScore?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .score(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .score(v)
        }
      }()
      case 12: try {
        var v: PBRationalRange?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .beatRange(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .beatRange(v)
        }
      }()
      case 13: try {
        var v: Double?
        try decoder.decodeSingularDoubleField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .normalizationValue(v)
        }
      }()
      case 14: try {
        var v: PBNotesValue?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .notesValue(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .notesValue(v)
        }
      }()
      case 15: try {
        var v: PBTone?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .tone(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .tone(v)
        }
      }()
      case 16: try {
        var v: PBRational?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .normalizationRationalValue(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .normalizationRationalValue(v)
        }
      }()
      case 21: try {
        var v: PBImage?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .image(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .image(v)
        }
      }()
      case 22: try {
        var v: PBContent?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .content(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .content(v)
        }
      }()
      case 23: try {
        var v: PBEnvelope?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .envelope(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .envelope(v)
        }
      }()
      case 24: try {
        var v: PBStereo?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .stereo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .stereo(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.value {
    case .copiedSheetsValue?: try {
      guard case .copiedSheetsValue(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .sheetValue?: try {
      guard case .sheetValue(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .border?: try {
      guard case .border(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .text?: try {
      guard case .text(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .string?: try {
      guard case .string(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }()
    case .picture?: try {
      guard case .picture(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .planesValue?: try {
      guard case .planesValue(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .uuColor?: try {
      guard case .uuColor(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .animation?: try {
      guard case .animation(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .ids?: try {
      guard case .ids(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .score?: try {
      guard case .score(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .beatRange?: try {
      guard case .beatRange(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .normalizationValue?: try {
      guard case .normalizationValue(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 13)
    }()
    case .notesValue?: try {
      guard case .notesValue(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .tone?: try {
      guard case .tone(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .normalizationRationalValue?: try {
      guard case .normalizationRationalValue(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .image?: try {
      guard case .image(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
    }()
    case .content?: try {
      guard case .content(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
    }()
    case .envelope?: try {
      guard case .envelope(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
    }()
    case .stereo?: try {
      guard case .stereo(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PBPastableObject, rhs: PBPastableObject) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
